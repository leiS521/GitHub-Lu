[{"title":"Windows服务","date":"2018-08-31T03:20:11.000Z","path":"2018/08/31/Windows服务/","text":"目前有个需求是新增的表单数据里面有个截止时间，需要根据截止时间的前24小时，1小时，15分钟来定时的推送，提醒APP用户当前表单快要到期。。。。 个人笔记 C#可以开发Windows服务，每分钟查询一次数据库，保持占用数据库连接的频率太高了，会导致其他API不稳定。然后决定采用Redis来存储数据，表单新增，修改，删除的时候同步操作Redis数据，这样保持Redis数据实时更新有效。Windows服务定期查询Redis数据，对于符合条件的数据执行推送及提醒代码 Redis数据结构Redis目前有五种数据结构，那么如何去选择符合当前业务的数据结构呢 结构类型 结构存储的值 结构的读写能力 string 可以是字符串啊，整数，浮点数 对整个字符串或者字符串的其中一分部分进行操作，对整数和浮点数执行的自增或自减操作 list 一个链表，链表上每个节点都包含了一个字符串 从链表的两端推入或弹出元素，根据偏移量对链表进行修剪；读取单个或多个元素，根据值查找或者移除元素 set 包含字符串的无序收集器，并且被包含的每个字符都是独一无二各不相同的 添加、获取、移除单个元素，检查一个元素是否存在与集合中，计算交集，并集，差集，从集合里面随机获取元素 hash 包含键值对的无序散列表 添加、获取、移除单个键值对，获取所有单个键值对 zset 字符串成员与浮点数分值之间的有序映射，元素的排列顺序由分值的大小决定 添加、获取、删除单个元素，根据分值范围或成员来获取元素 关于使用场景在这里推荐两个网站 菜鸟教程-Redis数据结构的使用场景 redis5种数据结构讲解及使用场景 设计最后我出于三个原因选择了无序列表（集合） 无序列表元素唯一，存储量大Set可包含的最大元素数量是4294967295 Sets之间的聚合计算操作效率极高 使用Redis客户端查看Key只有一个，Value是个列表，界面简洁，查询方便 最后通过Redis观察的数据结构是这样的 基于项目代码做了个Demo，希望不要吝啬你的小星星","tags":[{"name":".net","slug":"net","permalink":"http://tamron.club/tags/net/"}]},{"title":"数据库执行计划","date":"2018-08-19T03:20:11.000Z","path":"2018/08/19/数据库执行计划/","text":"数据库的执行计划通俗点说就是，数据库服务器在执行sql语句的时候，会准备几套方案，最后选择消耗资源最小的那个方案。就是执行计划。 个人笔记 比如执行一条sql语句，但是server并没有告诉服务器如何去做。服务器在收到sql语句后会先检查语法错误，没有问题才会解析执行。在这个过程中，他会考虑是执行整张表，还是根据索引呢，服务器会比较所有可能的方法所好的资源，最终sql语句被物理性执行的计划叫做执行计划， 执行计划在哪里 执行计划有哪些 【Table Scan】：遍历整个表，查找所有匹配的记录行。这个操作将会一行一行的检查，当然，效率也是最差的。 全表扫描，大数据扫描必定性能差，查找必定性能高 【Index Scan】：根据索引，从表中过滤出来一部分记录，再查找所有匹配的记录行，显然比第一种方式的查找范围要小，因此比【Table Scan】要快。 引起全表扫描并不是like，而是% 当前匹配的查询条件可以使用非聚集索引，可能是有&lt;,&gt;,%等等放弃了使用非聚集索引查找 【Index Seek】：根据索引，定位（获取）记录的存放位置，然后取得记录，因此，比起前二种方式会更快。 非聚集索引查找索引页然后再获取数据，这里有个坑是你Select 查找的字段必须是聚集索引，或者是非聚集索引，如果查找了*,或者其他字段，那将是全表扫描 【Clustered Index Scan】：和【Table Scan】一样。注意：不要以为这里有个Index，就认为不一样了。 其实它的意思是说：按聚集索引来逐行扫描每一行记录，因为记录就是按聚集索引来顺序存放的。 而【Table Scan】只是说：要扫描的表没有聚集索引而已，因此这二个操作本质上也是一样的。 意思是表里面有聚集索引，但是没有利用聚集索引去查找 【Clustered Index Seek】：直接根据聚集索引获取记录，最快！ 完美，我们永远只会记住第一 如何去优化？当发现某个查询比较慢时，可以首先检查哪些操作的成本比较高，再看看那些操作在查找记录时， 是不是【Table Scan】或者【Clustered Index Scan】，如果确实和这二种操作类型有关，则要考虑增加索引来解决了。关于索引的记录请查看这里 这里推荐一篇博客，这篇信息讲的非常详细，但是今天这篇文章记录的是SqlServer中的执行计划 目前我的数据库安装版本是SqlServer2017服务和SSMS客户端 这里只是做个笔记，上次本地数据库导入百万条数据等待时间太长放弃了 最后引用MSDN原话：不要总是将索引的使用等同于良好的性能，或者将良好的性能等同于索引的高效使用。如果只要使用索引就能获得最佳性能，那查询优化器的工作就简单了。但事实上，不正确的索引选择并不能获得最佳性能。因此，查询优化器的任务是只在索引或索引组合能提高性能时才选择它，而在索引检索有碍性能时则避免使用它。","tags":[{"name":"数据库","slug":"数据库","permalink":"http://tamron.club/tags/数据库/"}]},{"title":"数据库索引优化","date":"2018-08-16T03:20:11.000Z","path":"2018/08/16/数据库索引优化/","text":"数据库索引优化之从入门到放弃。。。 个人笔记 索引是关系型数据库中给数据库表中一列或多列的值排序后的存储结构，SQL的主流索引结构有B+树以及Hash结构，聚集索引以及非聚集索引用的是B+树索引。数据库存储数据的格式为数据页面，每页的大小为8KB，nvarchar(8096) 概念聚集（clustered）索引，也叫聚簇索引。 定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。 非聚集（unclustered）索引。 定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。 如何去理解？现在有一个图书馆，里面放50本书（不要在意一个只有50本书的图书馆）。其中有一本书叫做《Java从入门到放弃》，现在要求进去快速的找到这本书？？？ A同学：我进去扫一眼就找到了，用了10秒 B同学：我进去也扫了一眼，但是没发现，又扫了一眼找到的用了15秒 为什么有的每个同学找到的速度不一样，为什么同样的Sql查询的时间每次都不一样？ 因为每个电脑硬件配置不一样，网速以及外界影响会导致查询时间不同 图书馆：我今天把书整理一下吧，他把书从A到Z的顺序排了个顺序 A同学：我进去还是扫一眼就找到了，用了5秒 B同学：我进去也扫了一眼也用了5秒 整理了的书肯定直接找J开头的书，所以能快速的找到这本书 这就是聚集索引，我把数据根据某个字段进行物理的排序，我（服务器）找数据会提高速度 图书馆：今天进了100万本书 A同学：我进去问了一下图书管理员，他帮我查了一下书在H货架放着，我去一下找到了花了2秒 B同学：我进去找J开头书籍，可是J开头的书太多了啊，我花了1分钟 A同学典型的非聚集索引查找方法，因为他去查找索引页（图书管理员）然后再去找书的 B同学是聚集索引查找方法，因为他还是根据物理排序的J去慢慢找的 通过这个故事，应该对聚集索引和非聚集索引有个大概的认识了 8月10号我和公司的DBA交流了一下： 索引这个东西不是加就好，跟电脑配置，网速都有关系。有时候你加索引还没有不加索引的查询速度快，所以索引适合在具有大数据量的情况下去进行优化。 主键是GUID建立聚集索引没有任何意义，对资源的一种浪费。建议把聚集索引建立在int,datetime型上 主键是什么？后来自己本地练习了一下。 我创建表的时候，设置一个主键，数据库会自动的给主键建立聚集索引。 然后我把聚集索引删除了，发现表中的主键也消失了。。。 我开始上网查资料，看博客 https://www.cnblogs.com/lj820403/p/7246657.html 主键寄宿于索引，主键的特性是唯一性约束。 索引的重点笔记 非聚集索引的建立会影响新增修改等操作的性能，所以并非非聚集索引越多越好 聚集索引只能建立一个，但是可以建立在多个字段上 非聚集索引可以建立多个，也可以建立多个字段 一个表索引最多不要超过5个 SQL的优化，使用like，is null,not null,&lt;,&gt;等可能会造成表放弃索引使用全表搜索（索引报废） GUID不建议做聚集索引，没有意义。聚集索引一般做在int,bingint,datetime上 非聚集索引适合建立在where条件经常查询的字段上","tags":[{"name":"数据库","slug":"数据库","permalink":"http://tamron.club/tags/数据库/"}]},{"title":"23种设计模式概念","date":"2018-07-17T00:07:04.000Z","path":"2018/07/17/23种设计模式概念/","text":"1.创建型模式工厂方法（Factory Method）在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节。工厂方法模式的核心是一个抽象工厂类，各种具体工厂类通过抽象工厂类将工厂方法继承下来。如此使得客户可以只关心抽象产品和抽象工厂，完全不用理会返回的是哪一种具体产品，也不用关系它是如何被具体工厂创建的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&gt; namespace 设计模式之工厂方法模式&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 菜抽象类&gt; /// &lt;/summary&gt;&gt; public abstract class Food&gt; &#123;&gt; // 输出点了什么菜&gt; public abstract void Print();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 西红柿炒鸡蛋这道菜&gt; /// &lt;/summary&gt;&gt; public class TomatoScrambledEggs : Food&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;西红柿炒蛋好了！&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 土豆肉丝这道菜&gt; /// &lt;/summary&gt;&gt; public class ShreddedPorkWithPotatoes : Food&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;土豆肉丝好了&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 抽象工厂类&gt; /// &lt;/summary&gt;&gt; public abstract class Creator&gt; &#123;&gt; // 工厂方法&gt; public abstract Food CreateFoddFactory();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 西红柿炒蛋工厂类&gt; /// &lt;/summary&gt;&gt; public class TomatoScrambledEggsFactory:Creator&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 负责创建西红柿炒蛋这道菜&gt; /// &lt;/summary&gt;&gt; /// &lt;returns&gt;&lt;/returns&gt;&gt; public override Food CreateFoddFactory()&gt; &#123;&gt; return new TomatoScrambledEggs();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 土豆肉丝工厂类&gt; /// &lt;/summary&gt;&gt; public class ShreddedPorkWithPotatoesFactory:Creator&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 负责创建土豆肉丝这道菜&gt; /// &lt;/summary&gt;&gt; /// &lt;returns&gt;&lt;/returns&gt;&gt; public override Food CreateFoddFactory()&gt; &#123;&gt; return new ShreddedPorkWithPotatoes();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 客户端调用&gt; /// &lt;/summary&gt;&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 初始化做菜的两个工厂（）&gt; Creator shreddedPorkWithPotatoesFactory = new ShreddedPorkWithPotatoesFactory();&gt; Creator tomatoScrambledEggsFactory = new TomatoScrambledEggsFactory();&gt; &gt; // 开始做西红柿炒蛋&gt; Food tomatoScrambleEggs = tomatoScrambledEggsFactory.CreateFoddFactory();&gt; tomatoScrambleEggs.Print();&gt; &gt; //开始做土豆肉丝&gt; Food shreddedPorkWithPotatoes = shreddedPorkWithPotatoesFactory.CreateFoddFactory();&gt; shreddedPorkWithPotatoes.Print();&gt; &gt; Console.Read();&gt; &#125;&gt; &#125; &gt; &#125;&gt; 2.抽象工厂模式（Abstract Factory）抽象工厂模式的主要优点是隔离了具体类的生成，使得客户不需要知道什么被创建了。犹豫这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变这个软件的系统的行为。另外，应用抽象工厂模式符合GRASP纯虚构的模式，可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&gt; /// &lt;summary&gt;&gt; /// 下面以绝味鸭脖连锁店为例子演示下抽象工厂模式&gt; /// 因为每个地方的喜欢的口味不一样，有些地方喜欢辣点的，有些地方喜欢吃不辣点&gt; /// 客户端调用&gt; /// &lt;/summary&gt;&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 南昌工厂制作南昌的鸭脖和鸭架&gt; AbstractFactory nanChangFactory = new NanChangFactory();&gt; YaBo nanChangYabo = nanChangFactory.CreateYaBo();&gt; nanChangYabo.Print();&gt; YaJia nanChangYajia= nanChangFactory.CreateYaJia();&gt; nanChangYajia.Print();&gt; &gt; // 上海工厂制作上海的鸭脖和鸭架&gt; AbstractFactory shangHaiFactory = new ShangHaiFactory();&gt; shangHaiFactory.CreateYaBo().Print();&gt; shangHaiFactory.CreateYaJia().Print();&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 抽象工厂类，提供创建两个不同地方的鸭架和鸭脖的接口&gt; /// &lt;/summary&gt;&gt; public abstract class AbstractFactory&gt; &#123;&gt; // 抽象工厂提供创建一系列产品的接口，这里作为例子，只给出了绝味中鸭脖和鸭架的创建接口&gt; public abstract YaBo CreateYaBo();&gt; public abstract YaJia CreateYaJia();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 南昌绝味工厂负责制作南昌的鸭脖和鸭架&gt; /// &lt;/summary&gt;&gt; public class NanChangFactory : AbstractFactory&gt; &#123;&gt; // 制作南昌鸭脖&gt; public override YaBo CreateYaBo()&gt; &#123;&gt; return new NanChangYaBo();&gt; &#125;&gt; // 制作南昌鸭架&gt; public override YaJia CreateYaJia()&gt; &#123;&gt; return new NanChangYaJia();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 上海绝味工厂负责制作上海的鸭脖和鸭架&gt; /// &lt;/summary&gt;&gt; public class ShangHaiFactory : AbstractFactory&gt; &#123;&gt; // 制作上海鸭脖&gt; public override YaBo CreateYaBo()&gt; &#123;&gt; return new ShangHaiYaBo();&gt; &#125;&gt; // 制作上海鸭架&gt; public override YaJia CreateYaJia()&gt; &#123;&gt; return new ShangHaiYaJia();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 鸭脖抽象类，供每个地方的鸭脖类继承&gt; /// &lt;/summary&gt;&gt; public abstract class YaBo&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 打印方法，用于输出信息&gt; /// &lt;/summary&gt;&gt; public abstract void Print();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 鸭架抽象类，供每个地方的鸭架类继承&gt; /// &lt;/summary&gt;&gt; public abstract class YaJia&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 打印方法，用于输出信息&gt; /// &lt;/summary&gt;&gt; public abstract void Print();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 南昌的鸭脖类，因为江西人喜欢吃辣的，所以南昌的鸭脖稍微会比上海做的辣&gt; /// &lt;/summary&gt;&gt; public class NanChangYaBo : YaBo&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;南昌的鸭脖&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 上海的鸭脖没有南昌的鸭脖做的辣&gt; /// &lt;/summary&gt;&gt; public class ShangHaiYaBo : YaBo&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;上海的鸭脖&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 南昌的鸭架&gt; /// &lt;/summary&gt;&gt; public class NanChangYaJia : YaJia&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;南昌的鸭架子&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 上海的鸭架&gt; /// &lt;/summary&gt;&gt; public class ShangHaiYaJia : YaJia&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;上海的鸭架子&quot;);&gt; &#125;&gt; &#125;&gt; 3.建造者模式（Builder Pattern）建造者模式将一个复杂对象的生成责任作了很好的分配。它把构造过程放在指挥者的方法中，把装配过程放到具体建造者类中。建造者模式的产品之间都有共通点，但有时候，产品之间的差异性很大，这就需要借助工厂方法模式或抽象工厂模式。另外，如果产品的内部变化复杂，Builder的每一个子类都需要对应到不同的产品去做构建的动作、方法，这就需要定义很多个具体建造类来实现这种变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&gt; using System;&gt; using System.Collections.Generic;&gt; using System.Linq;&gt; using System.Text;&gt; &gt; &gt; /// &lt;summary&gt;&gt; /// 以组装电脑为例子&gt; /// 每台电脑的组成过程都是一致的，但是使用同样的构建过程可以创建不同的表示(即可以组装成不一样的电脑，配置不一样)&gt; /// 组装电脑的这个场景就可以应用建造者模式来设计&gt; /// &lt;/summary&gt;&gt; namespace 设计模式之建造者模式&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 客户类&gt; /// &lt;/summary&gt;&gt; class Customer&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 客户找到电脑城老板说要买电脑，这里要装两台电脑&gt; // 创建指挥者和构造者&gt; Director director = new Director();&gt; Builder b1 = new ConcreteBuilder1();&gt; Builder b2 = new ConcreteBuilder2();&gt; &gt; // 老板叫员工去组装第一台电脑&gt; director.Construct(b1);&gt; &gt; // 组装完，组装人员搬来组装好的电脑&gt; Computer computer1 = b1.GetComputer();&gt; computer1.Show();&gt; &gt; // 老板叫员工去组装第二台电脑&gt; director.Construct(b2);&gt; Computer computer2 = b2.GetComputer();&gt; computer2.Show();&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 小王和小李难道会自愿地去组装嘛，谁不想休息的，这必须有一个人叫他们去组装才会去的&gt; /// 这个人当然就是老板了，也就是建造者模式中的指挥者&gt; /// 指挥创建过程类&gt; /// &lt;/summary&gt;&gt; public class Director&gt; &#123;&gt; // 组装电脑&gt; public void Construct(Builder builder)&gt; &#123;&gt; builder.BuildPartCPU();&gt; builder.BuildPartMainBoard();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 电脑类&gt; /// &lt;/summary&gt;&gt; public class Computer&gt; &#123;&gt; // 电脑组件集合&gt; private IList&lt;string&gt; parts = new List&lt;string&gt;();&gt; &gt; // 把单个组件添加到电脑组件集合中&gt; public void Add(string part)&gt; &#123;&gt; parts.Add(part);&gt; &#125;&gt; &gt; public void Show()&gt; &#123;&gt; Console.WriteLine(&quot;电脑开始在组装.......&quot;);&gt; foreach (string part in parts)&gt; &#123;&gt; Console.WriteLine(&quot;组件&quot;+part+&quot;已装好&quot;);&gt; &#125;&gt; &gt; Console.WriteLine(&quot;电脑组装好了&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 抽象建造者，这个场景下为 &quot;组装人&quot; ，这里也可以定义为接口&gt; /// &lt;/summary&gt;&gt; public abstract class Builder&gt; &#123;&gt; // 装CPU&gt; public abstract void BuildPartCPU();&gt; // 装主板&gt; public abstract void BuildPartMainBoard();&gt; &gt; // 当然还有装硬盘，电源等组件，这里省略&gt; &gt; // 获得组装好的电脑&gt; public abstract Computer GetComputer();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 具体创建者，具体的某个人为具体创建者，例如：装机小王啊&gt; /// &lt;/summary&gt;&gt; public class ConcreteBuilder1 : Builder&gt; &#123;&gt; Computer computer = new Computer();&gt; public override void BuildPartCPU()&gt; &#123;&gt; computer.Add(&quot;CPU1&quot;);&gt; &#125;&gt; &gt; public override void BuildPartMainBoard()&gt; &#123;&gt; computer.Add(&quot;Main board1&quot;);&gt; &#125;&gt; &gt; public override Computer GetComputer()&gt; &#123;&gt; return computer;&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 具体创建者，具体的某个人为具体创建者，例如：装机小李啊&gt; /// 又装另一台电脑了&gt; /// &lt;/summary&gt;&gt; public class ConcreteBuilder2 : Builder&gt; &#123;&gt; Computer computer = new Computer();&gt; public override void BuildPartCPU()&gt; &#123;&gt; computer.Add(&quot;CPU2&quot;);&gt; &#125;&gt; &gt; public override void BuildPartMainBoard()&gt; &#123;&gt; computer.Add(&quot;Main board2&quot;);&gt; &#125;&gt; &gt; public override Computer GetComputer()&gt; &#123;&gt; return computer;&gt; &#125;&gt; &#125;&gt; &#125;&gt; 4.单例模式（Single Pattern）Singleton单例模式为一个面向对象的应用程序提供了对象唯一的访问点，不管它实现何种功能，此种模式都为设计及开发团队提供了共享的概念。然而，Singleton对象类派生子类就有很大的困难，只有在父类没有被实例化时才可以实现。值得注意的是，有些对象不可以做成Singleton，比如.net的数据库链接对象(Connection)，整个应用程序同享一个Connection对象会出现连接池溢出错误。另外，.net提供了自动废物回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是废物，自动消灭它并回收它的资源，下次利用时又会重新实例化，这种情况下应注意其状态的丢失。 12345678910111213141516171819202122232425262728&gt; /// &lt;summary&gt;&gt; /// 单例模式的实现&gt; /// &lt;/summary&gt;&gt; public class Singleton&gt; &#123;&gt; // 定义一个静态变量来保存类的实例&gt; private static Singleton uniqueInstance;&gt; &gt; // 定义私有构造函数，使外界不能创建该类实例&gt; private Singleton()&gt; &#123;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点&gt; /// &lt;/summary&gt;&gt; /// &lt;returns&gt;&lt;/returns&gt;&gt; public static Singleton GetInstance()&gt; &#123;&gt; // 如果类的实例不存在则创建，否则直接返回&gt; if (uniqueInstance == null)&gt; &#123;&gt; uniqueInstance = new Singleton();&gt; &#125;&gt; return uniqueInstance;&gt; &#125;&gt; &#125;&gt; 5.原型模式（Protype Pattern）原型模式得到了广泛的应用，特别是在创建对象成本较大的情况下(初始化需占用较长时间，占用太多CPU资源或网络资源。比如通过Webservice或DCOM创建对象，或者创建对象要装载大文件)，系统如果需要重复利用，新的对象可以通过原型模式对已有对象的属性进行复制并稍作修改来取得。另外，如果系统要保存对象的状态而对象的状态变化很小，或者对象本身占内存不大的时候，也可以用原型模式配合备忘录模式来应用。相反地，如果对象的状态变化很大，或者对象占用内存很大，那么采用状态模式会比原型模式更好。原型模式的缺点是在实现深层复制时需要编写复杂的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt; ///火影忍者中鸣人的影分身和孙悟空的的变都是原型模式&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 孙悟空 原型&gt; MonkeyKingPrototype prototypeMonkeyKing = new ConcretePrototype(&quot;MonkeyKing&quot;);&gt; &gt; // 变一个&gt; MonkeyKingPrototype cloneMonkeyKing = prototypeMonkeyKing.Clone() as ConcretePrototype;&gt; Console.WriteLine(&quot;Cloned1:\\t&quot;+cloneMonkeyKing.Id);&gt; &gt; // 变两个&gt; MonkeyKingPrototype cloneMonkeyKing2 = prototypeMonkeyKing.Clone() as ConcretePrototype;&gt; Console.WriteLine(&quot;Cloned2:\\t&quot; + cloneMonkeyKing2.Id);&gt; Console.ReadLine();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 孙悟空原型&gt; /// &lt;/summary&gt;&gt; public abstract class MonkeyKingPrototype&gt; &#123;&gt; public string Id &#123; get; set; &#125;&gt; public MonkeyKingPrototype(string id)&gt; &#123;&gt; this.Id = id;&gt; &#125;&gt; &gt; // 克隆方法，即孙大圣说“变”&gt; public abstract MonkeyKingPrototype Clone();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 创建具体原型&gt; /// &lt;/summary&gt;&gt; public class ConcretePrototype : MonkeyKingPrototype&gt; &#123;&gt; public ConcretePrototype(string id)&gt; : base(id)&gt; &#123; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 浅拷贝&gt; /// &lt;/summary&gt;&gt; /// &lt;returns&gt;&lt;/returns&gt;&gt; public override MonkeyKingPrototype Clone()&gt; &#123;&gt; // 调用MemberwiseClone方法实现的是浅拷贝，另外还有深拷贝&gt; return (MonkeyKingPrototype)this.MemberwiseClone();&gt; &#125;&gt; &#125;&gt; 6.结构型模式适配器模式（Adapter Pattern）适配器模式可以将一个类的接口和另一个类的接口匹配起来，使用的前提是你不能或不想修改原来的适配器母接口(adaptee)。例如，你向第三方购买了一些类、控件，但是没有源程序，这时，使用适配器模式，你可以统一对象访问接口。但客户调用可能需要变动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&gt; using System;&gt; /// 这里以插座和插头的例子来诠释适配器模式&gt; /// 现在我们买的电器插头是2个孔，但是我们买的插座只有3个孔的&gt; /// 这是我们想把电器插在插座上的话就需要一个电适配器&gt; namespace 设计模式之适配器模式&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 客户端，客户想要把2个孔的插头 转变成三个孔的插头，这个转变交给适配器就好&gt; /// 既然适配器需要完成这个功能，所以它必须同时具体2个孔插头和三个孔插头的特征&gt; /// &lt;/summary&gt;&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 现在客户端可以通过电适配要使用2个孔的插头了&gt; IThreeHole threehole = new PowerAdapter();&gt; threehole.Request();&gt; Console.ReadLine();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 三个孔的插头，也就是适配器模式中的目标角色&gt; /// &lt;/summary&gt;&gt; public interface IThreeHole&gt; &#123;&gt; void Request();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 两个孔的插头，源角色——需要适配的类&gt; /// &lt;/summary&gt;&gt; public abstract class TwoHole&gt; &#123;&gt; public void SpecificRequest()&gt; &#123;&gt; Console.WriteLine(&quot;我是两个孔的插头&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 适配器类，接口要放在类的后面&gt; /// 适配器类提供了三个孔插头的行为，但其本质是调用两个孔插头的方法&gt; /// &lt;/summary&gt;&gt; public class PowerAdapter:TwoHole,IThreeHole&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 实现三个孔插头接口方法&gt; /// &lt;/summary&gt;&gt; public void Request()&gt; &#123;&gt; // 调用两个孔插头方法&gt; this.SpecificRequest();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 7.桥接模式（Bridge Pattern）桥接模式可以从接口中分离实现功能，使得设计更具扩展性，这样，客户调用方法时根本不需要知道实现的细节。桥接模式减少了子类，假设程序要在2个操作系统中处理6种图像格式，纯粹的继承就需要(2*6)12个子类，而应用桥接模式，只需要(2+6)8个子类。它使得代码更清洁，生成的执行程序文件更小。 桥接模式的缺陷是抽象类与实现类的双向连接使得运行速度减慢。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt; /// &lt;summary&gt;&gt; /// 抽象概念中的遥控器，扮演抽象化角色&gt; /// &lt;/summary&gt;&gt; public class RemoteControl&gt; &#123;&gt; // 字段&gt; private TV implementor;&gt; &gt; // 属性&gt; public TV Implementor&gt; &#123;&gt; get &#123; return implementor; &#125;&gt; set &#123; implementor = value; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 开电视机，这里抽象类中不再提供实现了，而是调用实现类中的实现&gt; /// &lt;/summary&gt;&gt; public virtual void On()&gt; &#123;&gt; implementor.On();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 关电视机&gt; /// &lt;/summary&gt;&gt; public virtual void Off()&gt; &#123;&gt; implementor.Off();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 换频道&gt; /// &lt;/summary&gt;&gt; public virtual void SetChannel()&gt; &#123;&gt; implementor.tuneChannel();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 具体遥控器&gt; /// &lt;/summary&gt;&gt; public class ConcreteRemote : RemoteControl&gt; &#123;&gt; public override void SetChannel()&gt; &#123;&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; base.SetChannel();&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; &#125;&gt; &#125;&gt; 8.组合模式（Composite Pattern）组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新部件也更容易，因为它让客户忽略了层次的不同性，而它的结构又是动态的，提供了对象管理的灵活接口。组合模式对于树结构的控制有着神奇的功效，例如在人力资源系统的组织架构及ERP系统的BOM设计中，组合模式得到重点应用。组合模式的缺陷是使得设计变得更加抽象。对象的商业规则如果很复杂，则实现组合模式具有很大挑战性，并且，不是所有的方法都与叶部件子类有关联。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&gt; // 通过一些简单图形以及一些复杂图形构建图形树来演示组合模式&gt; // 客户端调用&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; ComplexGraphics complexGraphics = new ComplexGraphics(&quot;一个复杂图形和两条线段组成的复杂图形&quot;);&gt; complexGraphics.Add(new Line(&quot;线段A&quot;));&gt; ComplexGraphics CompositeCG = new ComplexGraphics(&quot;一个圆和一条线组成的复杂图形&quot;);&gt; CompositeCG.Add(new Circle(&quot;圆&quot;));&gt; CompositeCG.Add(new Circle(&quot;线段B&quot;));&gt; complexGraphics.Add(CompositeCG);&gt; Line l = new Line(&quot;线段C&quot;);&gt; complexGraphics.Add(l);&gt; &gt; // 显示复杂图形的画法&gt; Console.WriteLine(&quot;复杂图形的绘制如下：&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; complexGraphics.Draw();&gt; Console.WriteLine(&quot;复杂图形绘制完成&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; Console.WriteLine();&gt; &gt; // 移除一个组件再显示复杂图形的画法&gt; complexGraphics.Remove(l);&gt; Console.WriteLine(&quot;移除线段C后，复杂图形的绘制如下：&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; complexGraphics.Draw();&gt; Console.WriteLine(&quot;复杂图形绘制完成&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 图形抽象类，&gt; /// &lt;/summary&gt;&gt; public abstract class Graphics&gt; &#123;&gt; public string Name &#123; get; set; &#125;&gt; public Graphics(string name)&gt; &#123;&gt; this.Name = name;&gt; &#125;&gt; &gt; public abstract void Draw();&gt; public abstract void Add(Graphics g);&gt; public abstract void Remove(Graphics g);&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 简单图形类——线&gt; /// &lt;/summary&gt;&gt; public class Line : Graphics&gt; &#123;&gt; public Line(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; // 重写父类抽象方法&gt; public override void Draw()&gt; &#123;&gt; Console.WriteLine(&quot;画 &quot; + Name);&gt; &#125;&gt; // 因为简单图形在添加或移除其他图形，所以简单图形Add或Remove方法没有任何意义&gt; // 如果客户端调用了简单图形的Add或Remove方法将会在运行时抛出异常&gt; // 我们可以在客户端捕获该类移除并处理&gt; public override void Add(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Line添加其他图形&quot;);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Line移除其他图形&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 简单图形类——圆&gt; /// &lt;/summary&gt;&gt; public class Circle : Graphics&gt; &#123;&gt; public Circle(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; // 重写父类抽象方法&gt; public override void Draw()&gt; &#123;&gt; Console.WriteLine(&quot;画 &quot; + Name);&gt; &#125;&gt; &gt; public override void Add(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Circle添加其他图形&quot;);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Circle移除其他图形&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 复杂图形，由一些简单图形组成,这里假设该复杂图形由一个圆两条线组成的复杂图形&gt; /// &lt;/summary&gt;&gt; public class ComplexGraphics : Graphics&gt; &#123;&gt; private List&lt;Graphics&gt; complexGraphicsList = new List&lt;Graphics&gt;();&gt; &gt; public ComplexGraphics(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 复杂图形的画法&gt; /// &lt;/summary&gt;&gt; public override void Draw()&gt; &#123; &gt; foreach (Graphics g in complexGraphicsList)&gt; &#123;&gt; g.Draw();&gt; &#125;&gt; &#125;&gt; &gt; public override void Add(Graphics g)&gt; &#123;&gt; complexGraphicsList.Add(g);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; complexGraphicsList.Remove(g);&gt; &#125;&gt; &#125;&gt; 9.装饰模式（Decorator Pattern）装饰模式提供了比静态继承更好的柔韧性，它允许开发一系列的功能类用来代替增加对象的行为，这既不会污染原来对象的源码，还能使代码更容易编写，使类更具扩展性，因为变化都是由新的装饰类来完成。还可以建立连接的装饰对象关系链。需要注意的是，装饰链不宜过长。装饰链太长会使系统花费较长时间用于初始化对象，同时信息在链中的传递也会浪费太多的时间。这个情况好比物品包装，包了一层又一层，大包套小包。另外，如果原来的对象接口发生变化，它所以的装饰类都要修改以匹配它的变化。派生子类会影响对象的内部，而一个Decorator只会影响对象的外表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&gt; /// &lt;summary&gt;&gt; /// 手机抽象类，即装饰者模式中的抽象组件类&gt; /// &lt;/summary&gt;&gt; public abstract class Phone&gt; &#123;&gt; public abstract void Print();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 苹果手机，即装饰着模式中的具体组件类&gt; /// &lt;/summary&gt;&gt; public class ApplePhone:Phone&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 重写基类方法&gt; /// &lt;/summary&gt;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;开始执行具体的对象——苹果手机&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 装饰抽象类,要让装饰完全取代抽象组件，所以必须继承自Photo&gt; /// &lt;/summary&gt;&gt; public abstract class Decorator:Phone&gt; &#123;&gt; private Phone phone;&gt; &gt; public Decorator(Phone p)&gt; &#123;&gt; this.phone = p;&gt; &#125;&gt; &gt; public override void Print()&gt; &#123;&gt; if (phone != null)&gt; &#123;&gt; phone.Print();&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 贴膜，即具体装饰者&gt; /// &lt;/summary&gt;&gt; public class Sticker : Decorator&gt; &#123;&gt; public Sticker(Phone p)&gt; : base(p)&gt; &#123; &gt; &#125;&gt; &gt; public override void Print()&gt; &#123;&gt; base.Print();&gt; &gt; // 添加新的行为&gt; AddSticker(); &gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 新的行为方法&gt; /// &lt;/summary&gt;&gt; public void AddSticker()&gt; &#123;&gt; Console.WriteLine(&quot;现在苹果手机有贴膜了&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 手机挂件&gt; /// &lt;/summary&gt;&gt; public class Accessories : Decorator&gt; &#123;&gt; public Accessories(Phone p)&gt; : base(p)&gt; &#123;&gt; &#125;&gt; &gt; public override void Print()&gt; &#123;&gt; base.Print();&gt; &gt; // 添加新的行为&gt; AddAccessories(); &gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 新的行为方法&gt; /// &lt;/summary&gt;&gt; public void AddAccessories()&gt; &#123;&gt; Console.WriteLine(&quot;现在苹果手机有漂亮的挂件了&quot;);&gt; &#125;&gt; &#125;&gt; 10.外观模式（Façade Pattern）外观模式提供了一个简单且公用的接口去处理复杂的子系统，并且没有减少子系统的功能。它遮蔽了子系统的复杂性，避免了客户与子系统直接链接，它也减少了子系统与子系统间的连接，每个子系统都有它的Facade模式，每个子系统采用Facade模式去访问其他子系统。外观模式的劣势就是限制了客户的自由，减少了可变性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&gt; // 通过一些简单图形以及一些复杂图形构建图形树来演示组合模式&gt; // 客户端调用&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; ComplexGraphics complexGraphics = new ComplexGraphics(&quot;一个复杂图形和两条线段组成的复杂图形&quot;);&gt; complexGraphics.Add(new Line(&quot;线段A&quot;));&gt; ComplexGraphics CompositeCG = new ComplexGraphics(&quot;一个圆和一条线组成的复杂图形&quot;);&gt; CompositeCG.Add(new Circle(&quot;圆&quot;));&gt; CompositeCG.Add(new Circle(&quot;线段B&quot;));&gt; complexGraphics.Add(CompositeCG);&gt; Line l = new Line(&quot;线段C&quot;);&gt; complexGraphics.Add(l);&gt; &gt; // 显示复杂图形的画法&gt; Console.WriteLine(&quot;复杂图形的绘制如下：&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; complexGraphics.Draw();&gt; Console.WriteLine(&quot;复杂图形绘制完成&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; Console.WriteLine();&gt; &gt; // 移除一个组件再显示复杂图形的画法&gt; complexGraphics.Remove(l);&gt; Console.WriteLine(&quot;移除线段C后，复杂图形的绘制如下：&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; complexGraphics.Draw();&gt; Console.WriteLine(&quot;复杂图形绘制完成&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 图形抽象类，&gt; /// &lt;/summary&gt;&gt; public abstract class Graphics&gt; &#123;&gt; public string Name &#123; get; set; &#125;&gt; public Graphics(string name)&gt; &#123;&gt; this.Name = name;&gt; &#125;&gt; &gt; public abstract void Draw();&gt; public abstract void Add(Graphics g);&gt; public abstract void Remove(Graphics g);&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 简单图形类——线&gt; /// &lt;/summary&gt;&gt; public class Line : Graphics&gt; &#123;&gt; public Line(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; // 重写父类抽象方法&gt; public override void Draw()&gt; &#123;&gt; Console.WriteLine(&quot;画 &quot; + Name);&gt; &#125;&gt; // 因为简单图形在添加或移除其他图形，所以简单图形Add或Remove方法没有任何意义&gt; // 如果客户端调用了简单图形的Add或Remove方法将会在运行时抛出异常&gt; // 我们可以在客户端捕获该类移除并处理&gt; public override void Add(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Line添加其他图形&quot;);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Line移除其他图形&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 简单图形类——圆&gt; /// &lt;/summary&gt;&gt; public class Circle : Graphics&gt; &#123;&gt; public Circle(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; // 重写父类抽象方法&gt; public override void Draw()&gt; &#123;&gt; Console.WriteLine(&quot;画 &quot; + Name);&gt; &#125;&gt; &gt; public override void Add(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Circle添加其他图形&quot;);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Circle移除其他图形&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 复杂图形，由一些简单图形组成,这里假设该复杂图形由一个圆两条线组成的复杂图形&gt; /// &lt;/summary&gt;&gt; public class ComplexGraphics : Graphics&gt; &#123;&gt; private List&lt;Graphics&gt; complexGraphicsList = new List&lt;Graphics&gt;();&gt; &gt; public ComplexGraphics(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 复杂图形的画法&gt; /// &lt;/summary&gt;&gt; public override void Draw()&gt; &#123; &gt; foreach (Graphics g in complexGraphicsList)&gt; &#123;&gt; g.Draw();&gt; &#125;&gt; &#125;&gt; &gt; public override void Add(Graphics g)&gt; &#123;&gt; complexGraphicsList.Add(g);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; complexGraphicsList.Remove(g);&gt; &#125;&gt; &#125;&gt; 11.享元模式（Flyweight Pattern）Flyweight模式需要你认真考虑如何能细化对象，以减少处理的对象数量，从而减少存留对象在内存或其他存储设备中的占用量。然而，此模式需要维护大量对象的外部状态，如果外部状态的数据量大，传递、查找、计算这些恶数据会变得非常复杂。当外部和内部的状态很难分清时，不宜采用flyweight模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&gt; /// &lt;summary&gt;&gt; /// 客户端调用&gt; /// &lt;/summary&gt;&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 定义外部状态，例如字母的位置等信息&gt; int externalstate = 10;&gt; // 初始化享元工厂&gt; FlyweightFactory factory = new FlyweightFactory();&gt; &gt; // 判断是否已经创建了字母A，如果已经创建就直接使用创建的对象A&gt; Flyweight fa = factory.GetFlyweight(&quot;A&quot;);&gt; if (fa != null)&gt; &#123;&gt; // 把外部状态作为享元对象的方法调用参数&gt; fa.Operation(--externalstate);&gt; &#125;&gt; // 判断是否已经创建了字母B&gt; Flyweight fb = factory.GetFlyweight(&quot;B&quot;);&gt; if (fb != null)&gt; &#123;&gt; fb.Operation(--externalstate);&gt; &#125;&gt; // 判断是否已经创建了字母C&gt; Flyweight fc = factory.GetFlyweight(&quot;C&quot;);&gt; if (fc != null)&gt; &#123;&gt; fc.Operation(--externalstate);&gt; &#125;&gt; // 判断是否已经创建了字母D&gt; Flyweight fd= factory.GetFlyweight(&quot;D&quot;);&gt; if (fd != null)&gt; &#123;&gt; fd.Operation(--externalstate);&gt; &#125;&gt; else&gt; &#123;&gt; Console.WriteLine(&quot;驻留池中不存在字符串D&quot;);&gt; // 这时候就需要创建一个对象并放入驻留池中&gt; ConcreteFlyweight d = new ConcreteFlyweight(&quot;D&quot;);&gt; factory.flyweights.Add(&quot;D&quot;, d);&gt; &#125;&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 享元工厂，负责创建和管理享元对象&gt; /// &lt;/summary&gt;&gt; public class FlyweightFactory&gt; &#123;&gt; // 最好使用泛型Dictionary&lt;string,Flyweighy&gt;&gt; //public Dictionary&lt;string, Flyweight&gt; flyweights = new Dictionary&lt;string, Flyweight&gt;();&gt; public Hashtable flyweights = new Hashtable();&gt; &gt; public FlyweightFactory()&gt; &#123;&gt; flyweights.Add(&quot;A&quot;, new ConcreteFlyweight(&quot;A&quot;));&gt; flyweights.Add(&quot;B&quot;, new ConcreteFlyweight(&quot;B&quot;));&gt; flyweights.Add(&quot;C&quot;, new ConcreteFlyweight(&quot;C&quot;));&gt; &#125;&gt; &gt; public Flyweight GetFlyweight(string key)&gt; &#123;&gt; // 更好的实现如下&gt; //Flyweight flyweight = flyweights[key] as Flyweight;&gt; //if (flyweight == null)&gt; //&#123;&gt; // Console.WriteLine(&quot;驻留池中不存在字符串&quot; + key);&gt; // flyweight = new ConcreteFlyweight(key);&gt; //&#125;&gt; //return flyweight;&gt; return flyweights[key] as Flyweight;&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 抽象享元类，提供具体享元类具有的方法&gt; /// &lt;/summary&gt;&gt; public abstract class Flyweight&gt; &#123;&gt; public abstract void Operation(int extrinsicstate);&gt; &#125;&gt; &gt; // 具体的享元对象，这样我们不把每个字母设计成一个单独的类了，而是作为把共享的字母作为享元对象的内部状态&gt; public class ConcreteFlyweight : Flyweight&gt; &#123;&gt; // 内部状态&gt; private string intrinsicstate ;&gt; &gt; // 构造函数&gt; public ConcreteFlyweight(string innerState)&gt; &#123;&gt; this.intrinsicstate = innerState;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 享元类的实例方法&gt; /// &lt;/summary&gt;&gt; /// &lt;param name=&quot;extrinsicstate&quot;&gt;外部状态&lt;/param&gt;&gt; public override void Operation(int extrinsicstate)&gt; &#123;&gt; Console.WriteLine(&quot;具体实现类: intrinsicstate &#123;0&#125;, extrinsicstate &#123;1&#125;&quot;, intrinsicstate, extrinsicstate);&gt; &#125;&gt; &#125;&gt; 12.代理模式（Proxy Pattern）当对象在远程机器上，要通过网络来生成时，速度可能会慢，此时应用Remote Proxy模式，可以掩蔽对象由网络生成的过程，系统的速度会加快；对于大图片的加载，Virtual Proxy模式可以让加载在后台进行，前台用的Proxy对象使得整体运行速度得到优化；Protect Proxy可以验证对真实对象的引用权限。代理模式的缺陷是请求的处理速度会变慢，并且实现Proxy模式需要额外的工作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt; // 客户端调用&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 创建一个代理对象并发出请求&gt; Person proxy = new Friend();&gt; proxy.BuyProduct();&gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; // 抽象主题角色&gt; public abstract class Person&gt; &#123;&gt; public abstract void BuyProduct();&gt; &#125;&gt; &gt; //真实主题角色&gt; public class RealBuyPerson : Person&gt; &#123;&gt; public override void BuyProduct()&gt; &#123;&gt; Console.WriteLine(&quot;帮我买一个IPhone和一台苹果电脑&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 代理角色&gt; public class Friend:Person&gt; &#123;&gt; // 引用真实主题实例&gt; RealBuyPerson realSubject;&gt; &gt; public override void BuyProduct()&gt; &#123;&gt; Console.WriteLine(&quot;通过代理类访问真实实体对象的方法&quot;);&gt; if (realSubject == null)&gt; &#123;&gt; realSubject = new RealBuyPerson();&gt; &#125;&gt; &gt; this.PreBuyProduct();&gt; // 调用真实主题方法&gt; realSubject.BuyProduct();&gt; this.PostBuyProduct();&gt; &#125;&gt; &gt; // 代理角色执行的一些操作&gt; public void PreBuyProduct()&gt; &#123;&gt; // 可能不知一个朋友叫这位朋友带东西，首先这位出国的朋友要对每一位朋友要带的东西列一个清单等&gt; Console.WriteLine(&quot;我怕弄糊涂了，需要列一张清单，张三：要带相机，李四：要带Iphone...........&quot;);&gt; &#125;&gt; &gt; // 买完东西之后，代理角色需要针对每位朋友需要的对买来的东西进行分类&gt; public void PostBuyProduct()&gt; &#123;&gt; Console.WriteLine(&quot;终于买完了，现在要对东西分一下，相机是张三的；Iphone是李四的..........&quot;);&gt; &#125;&gt; &#125;&gt; 13.行为型模式职责链模式（Chain of Responsibility）责任链模式可以减少对象的连接，为对象责任分配增加了很大的灵活性。该模式允许把一组类作为一个类来使用，并且在类的组合中，一个类的事件可以发送到另一个类并由其处理。责任链模式通常应用与图形用户界面中，窗体的部件可能会包含其他几个小部件，就如同Windows窗体应用程序中，控件中又可以放置其他控件，控件边界会决定是否处理事件，或者将事件传递给父控件来处理。另外，责任链还会以树状出现，这样，一个事件可以传给多个类，或者，多个类的信息可以提交到一个类。树状责任链能够提供更灵活的技巧，但缺点是信息在树中容易迷失。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&gt; namespace ChainofResponsibility&gt; &#123;&gt; // 采购请求&gt; public class PurchaseRequest&gt; &#123;&gt; // 金额&gt; public double Amount &#123; get; set; &#125;&gt; // 产品名字&gt; public string ProductName &#123; get; set; &#125;&gt; public PurchaseRequest(double amount, string productName)&gt; &#123;&gt; Amount = amount;&gt; ProductName = productName;&gt; &#125;&gt; &#125;&gt; &gt; // 审批人,Handler&gt; public abstract class Approver&gt; &#123;&gt; public Approver NextApprover &#123; get; set; &#125;&gt; public string Name &#123; get; set; &#125;&gt; public Approver(string name)&gt; &#123;&gt; this.Name = name;&gt; &#125;&gt; public abstract void ProcessRequest(PurchaseRequest request);&gt; &#125;&gt; &gt; // ConcreteHandler&gt; public class Manager : Approver&gt; &#123;&gt; public Manager(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; public override void ProcessRequest(PurchaseRequest request)&gt; &#123;&gt; if (request.Amount &lt; 10000.0)&gt; &#123;&gt; Console.WriteLine(&quot;&#123;0&#125;-&#123;1&#125; approved the request of purshing &#123;2&#125;&quot;, this, Name, request.ProductName);&gt; &#125;&gt; else if (NextApprover != null)&gt; &#123;&gt; NextApprover.ProcessRequest(request);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; // ConcreteHandler,副总&gt; public class VicePresident : Approver&gt; &#123;&gt; public VicePresident(string name)&gt; : base(name)&gt; &#123; &gt; &#125;&gt; public override void ProcessRequest(PurchaseRequest request)&gt; &#123;&gt; if (request.Amount &lt; 25000.0)&gt; &#123;&gt; Console.WriteLine(&quot;&#123;0&#125;-&#123;1&#125; approved the request of purshing &#123;2&#125;&quot;, this, Name, request.ProductName);&gt; &#125;&gt; else if (NextApprover != null)&gt; &#123;&gt; NextApprover.ProcessRequest(request);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; // ConcreteHandler，总经理&gt; public class President :Approver&gt; &#123;&gt; public President(string name)&gt; : base(name)&gt; &#123; &#125;&gt; public override void ProcessRequest(PurchaseRequest request)&gt; &#123;&gt; if (request.Amount &lt; 100000.0)&gt; &#123;&gt; Console.WriteLine(&quot;&#123;0&#125;-&#123;1&#125; approved the request of purshing &#123;2&#125;&quot;, this, Name, request.ProductName);&gt; &#125;&gt; else&gt; &#123;&gt; Console.WriteLine(&quot;Request需要组织一个会议讨论&quot;);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; PurchaseRequest requestTelphone = new PurchaseRequest(4000.0, &quot;Telphone&quot;);&gt; PurchaseRequest requestSoftware = new PurchaseRequest(10000.0, &quot;Visual Studio&quot;);&gt; PurchaseRequest requestComputers = new PurchaseRequest(40000.0, &quot;Computers&quot;);&gt; &gt; Approver manager = new Manager(&quot;LearningHard&quot;);&gt; Approver Vp = new VicePresident(&quot;Tony&quot;);&gt; Approver Pre = new President(&quot;BossTom&quot;);&gt; &gt; // 设置责任链&gt; manager.NextApprover = Vp;&gt; Vp.NextApprover = Pre;&gt; &gt; // 处理请求&gt; manager.ProcessRequest(requestTelphone);&gt; manager.ProcessRequest(requestSoftware);&gt; manager.ProcessRequest(requestComputers);&gt; Console.ReadLine();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 14.命令模式（Command Pattern）命令模式分离了接受请求的对象与实现处理请求工作的对象，这样，已经存在的类可以保持不变，使得增加新类的工作更简单。例如，很多软件的宏命令就提高了系统的自动化程度。命令模式还可以分离用户界面和业务对象，降低系统的耦合度。但是，命令模式最主要的缺陷就是，类的数量增加了，系统变得更复杂，程序的调试工作也相应变得困难。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&gt; // 教官，负责调用命令对象执行请求&gt; public class Invoke&gt; &#123;&gt; public Command _command;&gt; &gt; public Invoke(Command command)&gt; &#123;&gt; this._command = command;&gt; &#125;&gt; &gt; public void ExecuteCommand()&gt; &#123;&gt; _command.Action();&gt; &#125;&gt; &#125;&gt; &gt; // 命令抽象类&gt; public abstract class Command &gt; &#123;&gt; // 命令应该知道接收者是谁，所以有Receiver这个成员变量&gt; protected Receiver _receiver;&gt; &gt; public Command(Receiver receiver)&gt; &#123;&gt; this._receiver = receiver;&gt; &#125;&gt; &gt; // 命令执行方法&gt; public abstract void Action();&gt; &#125;&gt; &gt; // &gt; public class ConcreteCommand :Command&gt; &#123;&gt; public ConcreteCommand(Receiver receiver)&gt; : base(receiver)&gt; &#123; &gt; &#125;&gt; &gt; public override void Action()&gt; &#123;&gt; // 调用接收的方法，因为执行命令的是学生&gt; _receiver.Run1000Meters();&gt; &#125;&gt; &#125;&gt; &gt; // 命令接收者——学生&gt; public class Receiver&gt; &#123;&gt; public void Run1000Meters()&gt; &#123;&gt; Console.WriteLine(&quot;跑1000米&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 院领导&gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 初始化Receiver、Invoke和Command&gt; Receiver r = new Receiver();&gt; Command c = new ConcreteCommand(r);&gt; Invoke i = new Invoke(c);&gt; &gt; // 院领导发出命令&gt; i.ExecuteCommand();&gt; &#125;&gt; &#125;&gt; 15.解释器模式（Interpreter Pattern）解释器模式的作用很强大，它使得改变和扩展文法变得容易，实现文法也变得简单明了，很多编译器，包括文本编辑器、网页浏览器及VRML都应用解释器模式。解释器模式的缺陷就是，因为文句会分析成树结构，解释器需要递归访问它，所以效率会受影响。这种情况开发人员会有所体会，编译整个工程源码耗费时间都比较长。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255&gt; namespace InterpreterPattern&gt; &#123;&gt; // 抽象表达式&gt; public abstract class Expression&gt; &#123;&gt; protected Dictionary&lt;string, int&gt; table = new Dictionary&lt;string, int&gt;(9);&gt; &gt; protected Expression()&gt; &#123;&gt; table.Add(&quot;一&quot;, 1);&gt; table.Add(&quot;二&quot;, 2);&gt; table.Add(&quot;三&quot;, 3);&gt; table.Add(&quot;四&quot;, 4);&gt; table.Add(&quot;五&quot;, 5);&gt; table.Add(&quot;六&quot;, 6);&gt; table.Add(&quot;七&quot;, 7);&gt; table.Add(&quot;八&quot;, 8);&gt; table.Add(&quot;九&quot;, 9);&gt; &#125;&gt; &gt; public virtual void Interpreter(Context context)&gt; &#123;&gt; if (context.Statement.Length == 0)&gt; &#123;&gt; return;&gt; &#125;&gt; &gt; foreach (string key in table.Keys)&gt; &#123;&gt; int value = table[key];&gt; &gt; if (context.Statement.EndsWith(key + GetPostFix()))&gt; &#123;&gt; context.Data += value * this.Multiplier();&gt; context.Statement = context.Statement.Substring(0, context.Statement.Length - this.GetLength());&gt; &#125;&gt; if (context.Statement.EndsWith(&quot;零&quot;))&gt; &#123;&gt; context.Statement = context.Statement.Substring(0, context.Statement.Length - 1);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; public abstract string GetPostFix();&gt; &gt; public abstract int Multiplier();&gt; &gt; //这个可以通用，但是对于个位数字例外，所以用虚方法&gt; public virtual int GetLength()&gt; &#123;&gt; return this.GetPostFix().Length + 1;&gt; &#125;&gt; &#125;&gt; &gt; //个位表达式&gt; public sealed class GeExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 1;&gt; &#125;&gt; &gt; public override int GetLength()&gt; &#123;&gt; return 1;&gt; &#125;&gt; &#125;&gt; &gt; //十位表达式&gt; public sealed class ShiExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;十&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 10;&gt; &#125;&gt; &#125;&gt; &gt; //百位表达式&gt; public sealed class BaiExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;百&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 100;&gt; &#125;&gt; &#125;&gt; &gt; //千位表达式&gt; public sealed class QianExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;千&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 1000;&gt; &#125;&gt; &#125;&gt; &gt; //万位表达式&gt; public sealed class WanExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;万&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 10000;&gt; &#125;&gt; &gt; public override void Interpreter(Context context)&gt; &#123;&gt; if (context.Statement.Length == 0)&gt; &#123;&gt; return;&gt; &#125;&gt; &gt; ArrayList tree = new ArrayList();&gt; &gt; tree.Add(new GeExpression());&gt; tree.Add(new ShiExpression());&gt; tree.Add(new BaiExpression());&gt; tree.Add(new QianExpression());&gt; &gt; foreach (string key in table.Keys)&gt; &#123;&gt; if (context.Statement.EndsWith(GetPostFix()))&gt; &#123;&gt; int temp = context.Data;&gt; context.Data = 0;&gt; &gt; context.Statement = context.Statement.Substring(0, context.Statement.Length - this.GetLength());&gt; &gt; foreach (Expression exp in tree)&gt; &#123;&gt; exp.Interpreter(context);&gt; &#125;&gt; context.Data = temp + context.Data * this.Multiplier();&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; //亿位表达式&gt; public sealed class YiExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;亿&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 100000000;&gt; &#125;&gt; &gt; public override void Interpreter(Context context)&gt; &#123;&gt; ArrayList tree = new ArrayList();&gt; &gt; tree.Add(new GeExpression());&gt; tree.Add(new ShiExpression());&gt; tree.Add(new BaiExpression());&gt; tree.Add(new QianExpression());&gt; &gt; foreach (string key in table.Keys)&gt; &#123;&gt; if (context.Statement.EndsWith(GetPostFix()))&gt; &#123;&gt; int temp = context.Data;&gt; context.Data = 0;&gt; context.Statement = context.Statement.Substring(0, context.Statement.Length - this.GetLength());&gt; &gt; foreach (Expression exp in tree)&gt; &#123;&gt; exp.Interpreter(context);&gt; &#125;&gt; context.Data = temp + context.Data * this.Multiplier();&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; //环境上下文&gt; public sealed class Context&gt; &#123;&gt; private string _statement;&gt; private int _data;&gt; &gt; public Context(string statement)&gt; &#123;&gt; this._statement = statement;&gt; &#125;&gt; &gt; public string Statement&gt; &#123;&gt; get &#123; return this._statement; &#125;&gt; set &#123; this._statement = value; &#125;&gt; &#125;&gt; &gt; public int Data&gt; &#123;&gt; get &#123; return this._data; &#125;&gt; set &#123; this._data = value; &#125;&gt; &#125;&gt; &#125;&gt; &gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; string roman = &quot;五亿七千三百零二万六千四百五十二&quot;;&gt; //分解：((五)亿)((七千)(三百)(零)(二)万)&gt; //((六千)(四百)(五十)(二))&gt; &gt; Context context = new Context(roman);&gt; ArrayList tree = new ArrayList();&gt; &gt; tree.Add(new GeExpression());&gt; tree.Add(new ShiExpression());&gt; tree.Add(new BaiExpression());&gt; tree.Add(new QianExpression());&gt; tree.Add(new WanExpression());&gt; tree.Add(new YiExpression());&gt; &gt; foreach (Expression exp in tree)&gt; &#123;&gt; exp.Interpreter(context);&gt; &#125;&gt; &gt; Console.Write(context.Data);&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 16.模版方法模式（Template Method）模版方法模式在一个类中形式化地定义算法，而由它的子类实现细节的处理。模版方法模式的优势是，在子类定义处理算法时不会改变算法的结构。模版方法的特点在于，每个不同的实现都需要定义一个子类，这也复合高内聚的责任分配模式，不能说成是它的缺点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&gt; // 客户端调用&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 创建一个菠菜实例并调用模板方法&gt; Spinach spinach = new Spinach();&gt; spinach.CookVegetabel();&gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; public abstract class Vegetabel&gt; &#123;&gt; // 模板方法，不要把模版方法定义为Virtual或abstract方法，避免被子类重写，防止更改流程的执行顺序&gt; public void CookVegetabel()&gt; &#123;&gt; Console.WriteLine(&quot;抄蔬菜的一般做法&quot;);&gt; this.pourOil();&gt; this.HeatOil();&gt; this.pourVegetable();&gt; this.stir_fry();&gt; &#125;&gt; &gt; // 第一步倒油&gt; public void pourOil()&gt; &#123;&gt; Console.WriteLine(&quot;倒油&quot;);&gt; &#125;&gt; &gt; // 把油烧热&gt; public void HeatOil()&gt; &#123;&gt; Console.WriteLine(&quot;把油烧热&quot;);&gt; &#125;&gt; &gt; // 油热了之后倒蔬菜下去，具体哪种蔬菜由子类决定&gt; public abstract void pourVegetable();&gt; &gt; // 开发翻炒蔬菜&gt; public void stir_fry()&gt; &#123;&gt; Console.WriteLine(&quot;翻炒&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 菠菜&gt; public class Spinach : Vegetabel&gt; &#123;&gt; &gt; public override void pourVegetable()&gt; &#123;&gt; Console.WriteLine(&quot;倒菠菜进锅中&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 大白菜&gt; public class ChineseCabbage : Vegetabel&gt; &#123; &gt; public override void pourVegetable()&gt; &#123;&gt; Console.WriteLine(&quot;倒大白菜进锅中&quot;);&gt; &#125;&gt; &#125;&gt; 17.迭代器模式（Iterator Pattern）迭代器模式支持在聚集中移动游标，使得访问聚合中的元素变得简单，简化了聚集的接口，封装了聚合的对象。迭代器模式还可以应用于对树结构的访问，程序不需要从头逐行代码查找相应位置，可控制到从子集开始查找，对于加快程序的运行速度有很重要的作用。迭代器模式的缺点是聚合密切相关，增加了耦合。但将这种耦合定义在抽象基类，可解决这个问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&gt; // 抽象聚合类&gt; public interface IListCollection&gt; &#123;&gt; Iterator GetIterator();&gt; &#125;&gt; &gt; // 迭代器抽象类&gt; public interface Iterator&gt; &#123;&gt; bool MoveNext();&gt; Object GetCurrent();&gt; void Next();&gt; void Reset();&gt; &#125;&gt; &gt; // 具体聚合类&gt; public class ConcreteList : IListCollection&gt; &#123;&gt; int[] collection;&gt; public ConcreteList()&gt; &#123;&gt; collection = new int[] &#123; 2, 4, 6, 8 &#125;;&gt; &#125;&gt; &gt; public Iterator GetIterator()&gt; &#123;&gt; return new ConcreteIterator(this);&gt; &#125;&gt; &gt; public int Length&gt; &#123;&gt; get &#123; return collection.Length; &#125;&gt; &#125;&gt; &gt; public int GetElement(int index)&gt; &#123;&gt; return collection[index];&gt; &#125;&gt; &#125;&gt; &gt; // 具体迭代器类&gt; public class ConcreteIterator : Iterator&gt; &#123;&gt; // 迭代器要集合对象进行遍历操作，自然就需要引用集合对象&gt; private ConcreteList _list;&gt; private int _index;&gt; &gt; public ConcreteIterator(ConcreteList list)&gt; &#123;&gt; _list = list;&gt; _index = 0;&gt; &#125;&gt; &gt; &gt; public bool MoveNext()&gt; &#123;&gt; if (_index &lt; _list.Length)&gt; &#123;&gt; return true;&gt; &#125;&gt; return false;&gt; &#125;&gt; &gt; public Object GetCurrent()&gt; &#123;&gt; return _list.GetElement(_index);&gt; &#125;&gt; &gt; public void Reset()&gt; &#123;&gt; _index = 0;&gt; &#125;&gt; &gt; public void Next()&gt; &#123;&gt; if (_index &lt; _list.Length)&gt; &#123;&gt; _index++;&gt; &#125;&gt; &gt; &#125;&gt; &#125;&gt; // 客户端&gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; Iterator iterator;&gt; IListCollection list = new ConcreteList();&gt; iterator = list.GetIterator();&gt; &gt; while (iterator.MoveNext())&gt; &#123;&gt; int i = (int)iterator.GetCurrent();&gt; Console.WriteLine(i.ToString());&gt; iterator.Next();&gt; &#125;&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; 18.观察者模式（Oberver Pattern）观察者模式抽象了被观察对象与观察者对象的连接，提供了广播式的对象间通信，并且容易增加新的观察者对象。观察者模式的缺陷是对象间的关系难以理解，在某种情况下会表现低效能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt; // 腾讯游戏订阅号类&gt; public class TenxunGame&gt; &#123;&gt; // 订阅者对象&gt; public Subscriber Subscriber &#123;get;set;&#125; &gt; &gt; public String Symbol &#123;get; set;&#125;&gt; &gt; public string Info &#123;get ;set;&#125;&gt; &gt; public void Update()&gt; &#123;&gt; if (Subscriber != null)&gt; &#123;&gt; // 调用订阅者对象来通知订阅者&gt; Subscriber.ReceiveAndPrintData(this);&gt; &#125;&gt; &#125;&gt; &gt; &#125;&gt; // 订阅者类&gt; public class Subscriber&gt; &#123;&gt; public string Name &#123; get; set; &#125;&gt; public Subscriber(string name)&gt; &#123;&gt; this.Name = name;&gt; &#125;&gt; &gt; public void ReceiveAndPrintData(TenxunGame txGame)&gt; &#123;&gt; Console.WriteLine(&quot;Notified &#123;0&#125; of &#123;1&#125;&apos;s&quot; + &quot; Info is: &#123;2&#125;&quot;, Name, txGame.Symbol, txGame.Info);&gt; &#125;&gt; &#125;&gt; // 客户端测试&gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 实例化订阅者和订阅号对象&gt; Subscriber LearningHardSub = new Subscriber(&quot;LearningHard&quot;);&gt; TenxunGame txGame = new TenxunGame();&gt; &gt; txGame.Subscriber = LearningHardSub;&gt; txGame.Symbol = &quot;TenXun Game&quot;;&gt; txGame.Info = &quot;Have a new game published ....&quot;;&gt; &gt; txGame.Update();&gt; &gt; Console.ReadLine();&gt; &#125;&gt; &#125;&gt; 19.中介者模式（Mediator Pattern）中介者模式分离了两个同事类，简化了对象协议，中央控制对象交互，从而使个体对象变得更容易且更简单，因为它不需要传递数据给其他个体对象，仅仅传给中介者就可以了。个体对象不需要具有处理内部交流的逻辑，所以更加突出它的面向对象特性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&gt; // 抽象牌友类&gt; public abstract class AbstractCardPartner&gt; &#123;&gt; public int MoneyCount &#123; get; set; &#125;&gt; &gt; public AbstractCardPartner()&gt; &#123;&gt; MoneyCount = 0;&gt; &#125;&gt; &gt; public abstract void ChangeCount(int Count, AbstractCardPartner other);&gt; &#125;&gt; &gt; // 牌友A类&gt; public class ParterA : AbstractCardPartner&gt; &#123;&gt; public override void ChangeCount(int Count, AbstractCardPartner other)&gt; &#123;&gt; this.MoneyCount += Count;&gt; other.MoneyCount -= Count;&gt; &#125;&gt; &#125;&gt; &gt; // 牌友B类&gt; public class ParterB : AbstractCardPartner&gt; &#123;&gt; public override void ChangeCount(int Count, AbstractCardPartner other)&gt; &#123;&gt; this.MoneyCount += Count;&gt; other.MoneyCount -= Count;&gt; &#125;&gt; &#125;&gt; &gt; class Program&gt; &#123;&gt; // A,B两个人打牌&gt; static void Main(string[] args)&gt; &#123;&gt; AbstractCardPartner A = new ParterA();&gt; A.MoneyCount = 20;&gt; AbstractCardPartner B = new ParterB();&gt; B.MoneyCount = 20;&gt; &gt; // A 赢了则B的钱就减少&gt; A.ChangeCount(5, B);&gt; Console.WriteLine(&quot;A 现在的钱是：&#123;0&#125;&quot;, A.MoneyCount);// 应该是25&gt; Console.WriteLine(&quot;B 现在的钱是：&#123;0&#125;&quot;, B.MoneyCount); // 应该是15&gt; &gt; // B赢了A的钱也减少&gt; B.ChangeCount(10, A);&gt; Console.WriteLine(&quot;A 现在的钱是：&#123;0&#125;&quot;, A.MoneyCount); // 应该是15&gt; Console.WriteLine(&quot;B 现在的钱是：&#123;0&#125;&quot;, B.MoneyCount); // 应该是25&gt; Console.Read(); &gt; &#125;&gt; &#125;&gt; 20.备忘录模式（Memento Pattern）Memento模式保存了封装的边界，一个Memento对象是另一种原发器对象的表示，不会被其他代码改动。这种模式简化了原发器对象，Memento只保存原发器的状态。采用堆栈备忘对象，可以实现多次取消操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&gt; // 联系人&gt; public class ContactPerson&gt; &#123;&gt; public string Name &#123; get; set; &#125;&gt; public string MobileNum &#123; get; set; &#125;&gt; &#125;&gt; &gt; // 发起人&gt; public class MobileOwner&gt; &#123;&gt; // 发起人需要保存的内部状态&gt; public List&lt;ContactPerson&gt; ContactPersons &#123; get; set; &#125;&gt; &gt; public MobileOwner(List&lt;ContactPerson&gt; persons)&gt; &#123;&gt; ContactPersons = persons;&gt; &#125;&gt; &gt; // 创建备忘录，将当期要保存的联系人列表导入到备忘录中 &gt; public ContactMemento CreateMemento()&gt; &#123;&gt; // 这里也应该传递深拷贝，new List方式传递的是浅拷贝，&gt; // 因为ContactPerson类中都是string类型,所以这里new list方式对ContactPerson对象执行了深拷贝&gt; // 如果ContactPerson包括非string的引用类型就会有问题，所以这里也应该用序列化传递深拷贝&gt; return new ContactMemento(new List&lt;ContactPerson&gt;(this.ContactPersons));&gt; &#125;&gt; &gt; // 将备忘录中的数据备份导入到联系人列表中&gt; public void RestoreMemento(ContactMemento memento)&gt; &#123;&gt; // 下面这种方式是错误的，因为这样传递的是引用，&gt; // 则删除一次可以恢复，但恢复之后再删除的话就恢复不了.&gt; // 所以应该传递contactPersonBack的深拷贝，深拷贝可以使用序列化来完成&gt; this.ContactPersons = memento.contactPersonBack;&gt; &#125;&gt; &gt; public void Show()&gt; &#123;&gt; Console.WriteLine(&quot;联系人列表中有&#123;0&#125;个人，他们是:&quot;, ContactPersons.Count);&gt; foreach (ContactPerson p in ContactPersons)&gt; &#123;&gt; Console.WriteLine(&quot;姓名: &#123;0&#125; 号码为: &#123;1&#125;&quot;, p.Name, p.MobileNum);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; // 备忘录&gt; public class ContactMemento&gt; &#123;&gt; // 保存发起人的内部状态&gt; public List&lt;ContactPerson&gt; contactPersonBack;&gt; &gt; public ContactMemento(List&lt;ContactPerson&gt; persons)&gt; &#123;&gt; contactPersonBack = persons;&gt; &#125;&gt; &#125;&gt; &gt; // 管理角色&gt; public class Caretaker&gt; &#123;&gt; public ContactMemento ContactM &#123; get; set; &#125;&gt; &#125;&gt; &gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; List&lt;ContactPerson&gt; persons = new List&lt;ContactPerson&gt;()&gt; &#123;&gt; new ContactPerson() &#123; Name= &quot;Learning Hard&quot;, MobileNum = &quot;123445&quot;&#125;,&gt; new ContactPerson() &#123; Name = &quot;Tony&quot;, MobileNum = &quot;234565&quot;&#125;,&gt; new ContactPerson() &#123; Name = &quot;Jock&quot;, MobileNum = &quot;231455&quot;&#125;&gt; &#125;;&gt; MobileOwner mobileOwner = new MobileOwner(persons);&gt; mobileOwner.Show();&gt; &gt; // 创建备忘录并保存备忘录对象&gt; Caretaker caretaker = new Caretaker();&gt; caretaker.ContactM = mobileOwner.CreateMemento();&gt; &gt; // 更改发起人联系人列表&gt; Console.WriteLine(&quot;----移除最后一个联系人--------&quot;);&gt; mobileOwner.ContactPersons.RemoveAt(2);&gt; mobileOwner.Show();&gt; &gt; // 恢复到原始状态&gt; Console.WriteLine(&quot;-------恢复联系人列表------&quot;);&gt; mobileOwner.RestoreMemento(caretaker.ContactM);&gt; mobileOwner.Show();&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; 21.状态模式（State Pattern）状态模式在对象内保存特定的状态并且就不同的状态履行不同的行为，它使状态的变化显得清晰明了，也很容易创建对象的新状态。状态模式在工作流或游戏等各种系统中大量使用，例如在政府OA系统中，一个批文的状态有多种：未办、正在处理、正在批示、正在审核和已经完成等各种状态。在网络游戏中，一个游戏活动存在开始、开玩、正在玩、输赢等各种状态。使用状态模式就可以实现游戏状态的总控，而游戏状态决定了游戏的各个方面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213&gt; namespace StatePatternSample&gt; &#123;&gt; public class Account&gt; &#123;&gt; public State State &#123;get;set;&#125;&gt; public string Owner &#123; get; set; &#125;&gt; public Account(string owner)&gt; &#123;&gt; this.Owner = owner;&gt; this.State = new SilverState(0.0, this);&gt; &#125;&gt; &gt; public double Balance &#123; get &#123;return State.Balance; &#125;&#125; // 余额&gt; // 存钱&gt; public void Deposit(double amount)&gt; &#123;&gt; State.Deposit(amount);&gt; Console.WriteLine(&quot;存款金额为 &#123;0:C&#125;——&quot;, amount);&gt; Console.WriteLine(&quot;账户余额为 =:&#123;0:C&#125;&quot;, this.Balance);&gt; Console.WriteLine(&quot;账户状态为: &#123;0&#125;&quot;, this.State.GetType().Name);&gt; Console.WriteLine();&gt; &#125;&gt; &gt; // 取钱&gt; public void Withdraw(double amount)&gt; &#123;&gt; State.Withdraw(amount);&gt; Console.WriteLine(&quot;取款金额为 &#123;0:C&#125;——&quot;,amount);&gt; Console.WriteLine(&quot;账户余额为 =:&#123;0:C&#125;&quot;, this.Balance);&gt; Console.WriteLine(&quot;账户状态为: &#123;0&#125;&quot;, this.State.GetType().Name);&gt; Console.WriteLine();&gt; &#125;&gt; &gt; // 获得利息&gt; public void PayInterest()&gt; &#123;&gt; State.PayInterest();&gt; Console.WriteLine(&quot;Interest Paid --- &quot;);&gt; Console.WriteLine(&quot;账户余额为 =:&#123;0:C&#125;&quot;, this.Balance);&gt; Console.WriteLine(&quot;账户状态为: &#123;0&#125;&quot;, this.State.GetType().Name);&gt; Console.WriteLine();&gt; &#125;&gt; &#125;&gt; &gt; // 抽象状态类&gt; public abstract class State&gt; &#123;&gt; // Properties&gt; public Account Account &#123; get; set; &#125;&gt; public double Balance &#123; get; set; &#125; // 余额&gt; public double Interest &#123; get; set; &#125; // 利率&gt; public double LowerLimit &#123; get; set; &#125; // 下限&gt; public double UpperLimit &#123; get; set; &#125; // 上限&gt; &gt; public abstract void Deposit(double amount); // 存款&gt; public abstract void Withdraw(double amount); // 取钱&gt; public abstract void PayInterest(); // 获得的利息&gt; &#125;&gt; &gt; // Red State意味着Account透支了&gt; public class RedState : State&gt; &#123;&gt; public RedState(State state)&gt; &#123;&gt; // Initialize&gt; this.Balance = state.Balance;&gt; this.Account = state.Account;&gt; Interest = 0.00;&gt; LowerLimit = -100.00;&gt; UpperLimit = 0.00;&gt; &#125;&gt; &gt; // 存款&gt; public override void Deposit(double amount)&gt; &#123;&gt; Balance += amount;&gt; StateChangeCheck();&gt; &#125;&gt; // 取钱&gt; public override void Withdraw(double amount)&gt; &#123;&gt; Console.WriteLine(&quot;没有钱可以取了！&quot;);&gt; &#125;&gt; &gt; public override void PayInterest()&gt; &#123;&gt; // 没有利息&gt; &#125;&gt; &gt; private void StateChangeCheck()&gt; &#123;&gt; if (Balance &gt; UpperLimit)&gt; &#123;&gt; Account.State = new SilverState(this);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; // Silver State意味着没有利息得&gt; public class SilverState :State&gt; &#123;&gt; public SilverState(State state)&gt; : this(state.Balance, state.Account)&gt; &#123; &gt; &#125;&gt; &gt; public SilverState(double balance, Account account)&gt; &#123;&gt; this.Balance = balance;&gt; this.Account = account;&gt; Interest = 0.00;&gt; LowerLimit = 0.00;&gt; UpperLimit = 1000.00;&gt; &#125;&gt; &gt; public override void Deposit(double amount)&gt; &#123;&gt; Balance += amount;&gt; StateChangeCheck();&gt; &#125;&gt; public override void Withdraw(double amount)&gt; &#123;&gt; Balance -= amount;&gt; StateChangeCheck();&gt; &#125;&gt; &gt; public override void PayInterest()&gt; &#123;&gt; Balance += Interest * Balance;&gt; StateChangeCheck();&gt; &#125;&gt; &gt; private void StateChangeCheck()&gt; &#123;&gt; if (Balance &lt; LowerLimit)&gt; &#123;&gt; Account.State = new RedState(this);&gt; &#125;&gt; else if (Balance &gt; UpperLimit)&gt; &#123;&gt; Account.State = new GoldState(this);&gt; &#125;&gt; &#125; &gt; &#125;&gt; &gt; // Gold State意味着有利息状态&gt; public class GoldState : State&gt; &#123;&gt; public GoldState(State state)&gt; &#123;&gt; this.Balance = state.Balance;&gt; this.Account = state.Account;&gt; Interest = 0.05;&gt; LowerLimit = 1000.00;&gt; UpperLimit = 1000000.00;&gt; &#125;&gt; // 存钱&gt; public override void Deposit(double amount)&gt; &#123;&gt; Balance += amount;&gt; StateChangeCheck();&gt; &#125;&gt; // 取钱&gt; public override void Withdraw(double amount)&gt; &#123;&gt; Balance -= amount;&gt; StateChangeCheck();&gt; &#125;&gt; public override void PayInterest()&gt; &#123;&gt; Balance += Interest * Balance;&gt; StateChangeCheck();&gt; &#125;&gt; &gt; private void StateChangeCheck()&gt; &#123;&gt; if (Balance &lt; 0.0)&gt; &#123;&gt; Account.State = new RedState(this);&gt; &#125;&gt; else if (Balance &lt; LowerLimit)&gt; &#123;&gt; Account.State = new SilverState(this);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; class App&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 开一个新的账户&gt; Account account = new Account(&quot;Learning Hard&quot;);&gt; &gt; // 进行交易&gt; // 存钱&gt; account.Deposit(1000.0);&gt; account.Deposit(200.0);&gt; account.Deposit(600.0);&gt; &gt; // 付利息&gt; account.PayInterest();&gt; &gt; // 取钱&gt; account.Withdraw(2000.00);&gt; account.Withdraw(500.00);&gt; &gt; // 等待用户输入&gt; Console.ReadKey();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 22.策略模式（Strategy Pattern）策略模式提供了替代派生的子类，并定义类的每个行为，剔除了代码中条件的判断语句，使得扩展和结合新的行为变得更容易，根本不需要变动应用程序。策略模式可以避免使用多重条件转移语句，系统变得更新灵活。应用策略模式会产生很多子类，这符合高内聚的责任分配模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&gt; namespace StrategyPattern&gt; &#123;&gt; // 所得税计算策略&gt; public interface ITaxStragety&gt; &#123;&gt; double CalculateTax(double income);&gt; &#125;&gt; &gt; // 个人所得税&gt; public class PersonalTaxStrategy : ITaxStragety&gt; &#123;&gt; public double CalculateTax(double income)&gt; &#123;&gt; return income * 0.12;&gt; &#125;&gt; &#125;&gt; &gt; // 企业所得税&gt; public class EnterpriseTaxStrategy : ITaxStragety&gt; &#123;&gt; public double CalculateTax(double income)&gt; &#123;&gt; return (income - 3500) &gt; 0 ? (income - 3500) * 0.045 : 0.0;&gt; &#125;&gt; &#125;&gt; &gt; public class InterestOperation&gt; &#123;&gt; private ITaxStragety m_strategy;&gt; public InterestOperation(ITaxStragety strategy)&gt; &#123;&gt; this.m_strategy = strategy;&gt; &#125;&gt; &gt; public double GetTax(double income)&gt; &#123;&gt; return m_strategy.CalculateTax(income);&gt; &#125;&gt; &#125;&gt; &gt; class App&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 个人所得税方式&gt; InterestOperation operation = new InterestOperation(new PersonalTaxStrategy());&gt; Console.WriteLine(&quot;个人支付的税为：&#123;0&#125;&quot;, operation.GetTax(5000.00));&gt; &gt; // 企业所得税&gt; operation = new InterestOperation(new EnterpriseTaxStrategy());&gt; Console.WriteLine(&quot;企业支付的税为：&#123;0&#125;&quot;, operation.GetTax(50000.00));&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 23.访问者模式（Visitor Pattern）Visitor(访问者)模式使得增加新的操作变得容易，它可以收集有关联的方法，而分离没有关联的方法，特别适用于分离因为不同原因而变化的事物，如“在男人中分离出男孩”。但Visitor模式常常要打破对象的封装性，visitor与element需要达成某些共识。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&gt; namespace DonotUsevistorPattern&gt; &#123;&gt; // 抽象元素角色&gt; public abstract class Element&gt; &#123; &gt; public abstract void Print();&gt; &#125;&gt; &gt; // 具体元素A&gt; public class ElementA : Element&gt; &#123; &gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;我是元素A&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 具体元素B&gt; public class ElementB : Element&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;我是元素B&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 对象结构&gt; public class ObjectStructure&gt; &#123;&gt; private ArrayList elements = new ArrayList();&gt; &gt; public ArrayList Elements&gt; &#123;&gt; get &#123; return elements; &#125;&gt; &#125;&gt; &gt; public ObjectStructure()&gt; &#123;&gt; Random ran = new Random();&gt; for (int i = 0; i &lt; 6; i++)&gt; &#123;&gt; int ranNum = ran.Next(10);&gt; if (ranNum &gt; 5)&gt; &#123;&gt; elements.Add(new ElementA());&gt; &#125;&gt; else&gt; &#123;&gt; elements.Add(new ElementB());&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; ObjectStructure objectStructure = new ObjectStructure();&gt; // 遍历对象结构中的对象集合，访问每个元素的Print方法打印元素信息&gt; foreach (Element e in objectStructure.Elements)&gt; &#123;&gt; e.Print();&gt; &#125;&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &#125;&gt;","tags":[{"name":".net","slug":"net","permalink":"http://tamron.club/tags/net/"}]},{"title":"基于Microsoft Exchange Server发送邮件","date":"2018-06-28T12:39:34.000Z","path":"2018/06/28/基于Microsoft Exchange Server发送邮件/","text":"由于项目需要需要一个邮件功能，需要将数据库里数据导出Excel并且自动发送邮件的功能，我就在网上查资料。基于SMTP与POP3协议的发送邮件网上代码很多，自己配置了一下可以实现。但是后来为了安全考虑（其实是公司有微软域邮箱），需要采用微软的Exchange Server发送邮件。。。。 首先我们需要安装一个Microsoft.Exchange.WebServices的Nuget包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt;/// 邮件发送服务/// &lt;/summary&gt;public class MailService&#123; /// &lt;summary&gt; /// /// &lt;/summary&gt; public static readonly MailService Instance = new MailService(); #region 邮件发送 /// &lt;summary&gt; /// 邮件服务配置 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static ExchangeService _ExchangeService() &#123; ExchangeService service = new ExchangeService(ExchangeVersion.Exchange2007_SP1); string user = ConfigurationManager.AppSettings[&quot;User&quot;]; string password = ConfigurationManager.AppSettings[&quot;password&quot;]; string domain = ConfigurationManager.AppSettings[&quot;Domain&quot;]; service.Credentials = new NetworkCredential(user, password, domain); service.TraceEnabled = true; ServicePointManager.ServerCertificateValidationCallback += CheckCert; service.AutodiscoverUrl(user+&quot;@sinooceangroup.com&quot;); return service; &#125; /// &lt;summary&gt; /// 检验证书始终返回true /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;certificate&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;chain&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;sslPolicyErrors&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; protected static bool CheckCert(Object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) &#123; return true; &#125; /// &lt;summary&gt; /// 封装EmailMessage保存封装方法 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; public void SendEmail(EmailMessage message) &#123; message.Save(); message.SendAndSaveCopy();// 发送 &#125; #endregion 上面是核心代码，接下来是如何调用 12345678910111213141516171819public IHttpActionResult SendMailTest(string email) &#123; var result = ControllerService.Run(() =&gt; &#123; var service = MailService._ExchangeService(); Microsoft.Exchange.WebServices.Data.EmailMessage message = new Microsoft.Exchange.WebServices.Data.EmailMessage(service); message.Subject = &quot;测试标题&quot;; message.Body = new Microsoft.Exchange.WebServices.Data.MessageBody(); message.Body.BodyType = Microsoft.Exchange.WebServices.Data.BodyType.HTML; var stream = File.OpenRead(HttpRuntime.AppDomainAppPath + &quot;/HtmlTemplate/mail.html&quot;); StreamReader sr = new StreamReader(stream); string str = sr.ReadToEnd();//字符串 message.Body.Text = str; message.ToRecipients.Add(email); MailService.Instance.SendEmail(message); &#125;); return Ok(result); &#125;","tags":[{"name":"邮件","slug":"邮件","permalink":"http://tamron.club/tags/邮件/"}]},{"title":"SMTP协议发送邮件","date":"2018-06-25T08:39:34.000Z","path":"2018/06/25/SMTP发送邮件/","text":"例如A使用163邮箱发送邮件给B(qq邮箱)。首先A会把邮件通过SMTP（Simple Mail Transfer Protocol）协议传输到163的Smtp服务器上，163的Smtp服务器会根据B的邮箱账号，把邮件通过Smtp协议发给QQ邮箱的Smtp服务器。QQ的Smtp服务器接收到邮件消息后会将之存储在QQ邮箱的邮件存储设备上。当B登陆QQ邮箱后，如果有新邮件，POP3服务器就会从QQ邮箱的邮件存储设备上读出邮件并通过POP3/IMAP服务发送给邮件客户端的B。12345678910111213141516171819202122232425262728293031323334353637private void SendMail() &#123; //简单邮件传输协议类 System.Net.Mail.SmtpClient client = new System.Net.Mail.SmtpClient(); client.Host = &quot;smtp.ym.163.com&quot;;//邮件服务器 client.Port = 25;//smtp主机上的端口号,默认是25. client.DeliveryMethod = System.Net.Mail.SmtpDeliveryMethod.Network;//邮件发送方式:通过网络发送到SMTP服务器 client.Credentials = new System.Net.NetworkCredential(&quot;登录人邮箱&quot;, &quot;邮箱密码&quot;);//凭证,发件人登录邮箱的用户名和密码 //电子邮件信息类 System.Net.Mail.MailAddress fromAddress = new System.Net.Mail.MailAddress(&quot;发送人邮箱&quot;, &quot;名称&quot;);//发件人Email,在邮箱是这样显示的,[发件人:小明&lt;panthervic@163.com&gt;;] System.Net.Mail.MailAddress toAddress = new System.Net.Mail.MailAddress(&quot;收件人邮箱&quot;, &quot;名称&quot;);//收件人Email,在邮箱是这样显示的, [收件人:小红&lt;43327681@163.com&gt;;] System.Net.Mail.MailMessage mailMessage = new System.Net.Mail.MailMessage(fromAddress, toAddress);//创建一个电子邮件类 mailMessage.Subject = &quot;TaskService停止&quot;; //string filePath = Server.MapPath(&quot;/index.html&quot;);//邮件的内容可以是一个html文本. //System.IO.StreamReader read = new System.IO.StreamReader(filePath, System.Text.Encoding.GetEncoding(&quot;GB2312&quot;)); //string mailBody = read.ReadToEnd(); //read.Close(); //mailMessage.Body = mailBody;//可为html格式文本 IPHostEntry fromHE = Dns.GetHostEntry(Dns.GetHostName()); IPEndPoint ipEndPointFrom = new IPEndPoint(fromHE.AddressList[1], 80); EndPoint EndPointFrom = (ipEndPointFrom); mailMessage.Body = &quot;服务器地址：&quot;+ EndPointFrom;//可为html格式文本 mailMessage.SubjectEncoding = System.Text.Encoding.UTF8;//邮件主题编码 mailMessage.BodyEncoding = System.Text.Encoding.UTF8;//邮件内容编码 mailMessage.IsBodyHtml = true;//邮件内容是否为html格式 mailMessage.Priority = System.Net.Mail.MailPriority.High;//邮件的优先级,有三个值:高(在邮件主题前有一个红色感叹号,表示紧急),低(在邮件主题前有一个蓝色向下箭头,表示缓慢),正常(无显示). try &#123; client.Send(mailMessage);//发送邮件 //client.SendAsync(mailMessage, &quot;ojb&quot;);异步方法发送邮件,不会阻塞线程. &#125; catch (Exception ex) &#123; Console.WriteLine(ex); &#125; &#125;","tags":[{"name":"邮件","slug":"邮件","permalink":"http://tamron.club/tags/邮件/"}]},{"title":"ExcelHelper","date":"2018-05-20T12:39:34.000Z","path":"2018/05/20/ExcelHelper/","text":"今天是很有意义的一天，520 需求: Web后台需要做一个Excel导入功能 我：看完需求以后，大概得设计Excel7个工作簿模板，9张数据库表 磨刀不误砍柴工，我迫切的需要一个Excel读取得公共类，然后基于强大的百度自己改造了一个。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/// &lt;summary&gt;/// 读取Excel数据到DataTable(公共类)/// &lt;/summary&gt;/// &lt;param name=&quot;fileName&quot;&gt;文件名称 string&lt;/param&gt;/// &lt;param name=&quot;sheets&quot;&gt;工作簿 int&lt;/param&gt;/// &lt;param name=&quot;rows&quot;&gt;从第几行读取 int&lt;/param&gt;/// &lt;param name=&quot;columns&quot;&gt;从第几列读取 int&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public DataTable GetExcelData(string fileName, int sheets, int rows, int columns)&#123; DataTable dataTable = new DataTable(); HttpPostedFile postFile = HttpContext.Current.Request.Files[fileName]; if (postFile == null) &#123; throw new Exception(&quot;无效的数据源&quot;); &#125; string uploadFileName = postFile.FileName; string path = HttpContext.Current.Server.MapPath(&quot;~/Resources/&quot; + uploadFileName); postFile.SaveAs(path); IWorkbook workbook = null; ISheet sheet = null; using (FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read)) &#123; if (Path.GetExtension(path).IndexOf(&quot;.xlsx&quot;) &gt;= 0) // 2007版本 &#123; workbook = new XSSFWorkbook(fileStream); &#125; else if (Path.GetExtension(path).IndexOf(&quot;.xls&quot;) &gt;= 0) // 2003版本 &#123; workbook = new HSSFWorkbook(fileStream); &#125; sheet = workbook.GetSheetAt(sheets); workbook.Close(); &#125; IRow row; ICell cell; // 列名 row = sheet.GetRow(rows); for (int i = columns; i &lt; row.LastCellNum; i++) &#123; cell = row.GetCell(i); if (cell != null) &#123; dataTable.Columns.Add(new DataColumn(cell.ToString())); &#125; &#125; // 数据 for (int i = rows + 1; i &lt;= sheet.LastRowNum; i++) &#123; row = sheet.GetRow(i); if (row != null) &#123; DataRow dataRow = dataTable.NewRow(); for (int j = columns; j &lt; dataTable.Columns.Count; ++j) &#123; cell = row.GetCell(j); if (cell != null) &#123; dataRow[j] = cell.ToString(); &#125; &#125; dataTable.Rows.Add(dataRow); &#125; &#125; if (File.Exists(path)) &#123; File.Delete(path); &#125; return dataTable;&#125; 上述代码的工作流程是将HttpPost请求中from-data参数文件读取到本地，然后根据我传入Excel名称，工作簿索引，行索引，列索引来读取Excel数据转化为Table，然后删除本地Excel文件。然后将Table转化为Model操作数据库，完美解决。 但是我在过程中出现了几个问题： 1.我在设计模板的时候，时间列（2018-6）我设置单元格格式为日期，结果代码无法识别，无奈我改成了文本类型，然后在模板里面加了输入提示 2.因为需求说不是所有数据都是必须填写的，我处理的逻辑是如果关键字段不写，那么后面这条数据都将没有意义。如果关键字段写了，后面的关联值没有写也是可以保存的，前提是数据库这些字段设计为可以为空的 因为C#的TryParse语法的结果使用out参数抛出的，我用起来异常的难受，并且增加了代码量，我使用泛型封装了一个方法,因为我就用到了这几种类型，后面如果再用到再去补充吧123456789101112131415161718192021222324public class DataConvertHelper&lt;T&gt; where T : new() &#123; public static T ConvertToBaseType(string fromData) &#123; T t = new T(); if (t.GetType() == typeof(System.Int32)) &#123; Int32.TryParse(fromData, out int result); return (T)(object)result; &#125; if (t.GetType() == typeof(System.Decimal)) &#123; decimal.TryParse(fromData, out decimal result); return (T)(object)result; &#125; if (t.GetType() == typeof(System.DateTime)) &#123; DateTime.TryParse(fromData, out DateTime result); return (T)(object)result; &#125; return default(T); &#125; &#125;&#125;","tags":[{"name":".net","slug":"net","permalink":"http://tamron.club/tags/net/"}]},{"title":"SqlDbHelper","date":"2018-05-12T12:39:34.000Z","path":"2018/05/12/SqlDbHelper/","text":"asp.net 项目基本上都是有数据库服务支持的，这就需要有一个比较常用的类支持文件。 闲话不多说，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376 /// &lt;summary&gt; /// 针对SQL Server数据库操作的通用类 /// &lt;/summary&gt; public class SqlDbHelper &#123; private string connectionString; /// &lt;summary&gt; /// 设置数据库连接字符串 /// &lt;/summary&gt; public string ConnectionString &#123; set &#123; connectionString = value; &#125; &#125; /// &lt;summary&gt; /// 构造函数（默认连接：xxxx） /// &lt;/summary&gt; public SqlDbHelper() : this(ConfigurationManager.ConnectionStrings[&quot;xxxx&quot;].ConnectionString) &#123; &#125; /// &lt;summary&gt; /// 构造函数（需要传入新的连接字符串） /// &lt;/summary&gt; /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt; public SqlDbHelper(string connectionString) &#123; this.connectionString = connectionString; &#125; #region 执行一个查询，并返回 DataTable /// &lt;summary&gt; /// 执行一个查询，并返回 DataTable /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的查询SQL文本命令&lt;/param&gt; public DataTable ExecuteDataTable(string sql) &#123; return ExecuteDataTable(sql, CommandType.Text, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回 DataTable /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; public DataTable ExecuteDataTable(string sql, CommandType commandType) &#123; return ExecuteDataTable(sql, commandType, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回 DataTable /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;param name=&quot;parameters&quot;&gt;Transact-SQL 语句或存储过程的参数数组&lt;/param&gt; public DataTable ExecuteDataTable(string sql, CommandType commandType, SqlParameter[] parameters) &#123; DataTable data = new DataTable();//实例化DataTable，用于装载查询结果集 using (SqlConnection connection = new SqlConnection(connectionString)) &#123; using (SqlCommand command = new SqlCommand(sql, connection)) &#123; command.CommandType = commandType;//设置command的CommandType为指定的CommandType //如果同时传入了参数，则添加这些参数 if (parameters != null) &#123; foreach (SqlParameter parameter in parameters) &#123; command.Parameters.Add(parameter); &#125; &#125; //通过包含查询SQL的SqlCommand实例来实例化SqlDataAdapter SqlDataAdapter adapter = new SqlDataAdapter(command); adapter.Fill(data); &#125; &#125; return data; &#125; #endregion #region 执行一个查询，并返回 SqlDataReader /// &lt;summary&gt; /// 执行一个查询，并返回 SqlDataReader /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的查询SQL文本命令&lt;/param&gt; public SqlDataReader ExecuteReader(string sql) &#123; return ExecuteReader(sql, CommandType.Text, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回 SqlDataReader /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; public SqlDataReader ExecuteReader(string sql, CommandType commandType) &#123; return ExecuteReader(sql, commandType, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回 SqlDataReader /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;param name=&quot;parameters&quot;&gt;Transact-SQL 语句或存储过程的参数数组&lt;/param&gt; public SqlDataReader ExecuteReader(string sql, CommandType commandType, SqlParameter[] parameters) &#123; SqlConnection connection = new SqlConnection(connectionString); SqlCommand command = new SqlCommand(sql, connection); //如果同时传入了参数，则添加这些参数 if (parameters != null) &#123; foreach (SqlParameter parameter in parameters) &#123; command.Parameters.Add(parameter); &#125; &#125; connection.Open(); //CommandBehavior.CloseConnection参数指示关闭Reader对象时关闭与其关联的Connection对象 return command.ExecuteReader(CommandBehavior.CloseConnection); &#125; #endregion #region 执行一个查询，并返回一行一列的 Object /// &lt;summary&gt; /// 执行一个查询，并返回一行一列的 Object /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的查询SQL文本命令&lt;/param&gt; public Object ExecuteScalar(string sql) &#123; return ExecuteScalar(sql, CommandType.Text, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回一行一列的 Object /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; public Object ExecuteScalar(string sql, CommandType commandType) &#123; return ExecuteScalar(sql, commandType, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回一行一列的 Object /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;param name=&quot;parameters&quot;&gt;Transact-SQL 语句或存储过程的参数数组&lt;/param&gt; public Object ExecuteScalar(string sql, CommandType commandType, SqlParameter[] parameters) &#123; object result = null; using (SqlConnection connection = new SqlConnection(connectionString)) &#123; using (SqlCommand command = new SqlCommand(sql, connection)) &#123; command.CommandType = commandType;//设置command的CommandType为指定的CommandType //如果同时传入了参数，则添加这些参数 if (parameters != null) &#123; foreach (SqlParameter parameter in parameters) &#123; command.Parameters.Add(parameter); &#125; &#125; connection.Open();//打开数据库连接 result = command.ExecuteScalar(); &#125; &#125; return result;//返回查询结果的第一行第一列，忽略其它行和列 &#125; #endregion #region 对数据库执行增删改操作 /// &lt;summary&gt; /// 对数据库执行增删改操作 /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的查询SQL文本命令&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int ExecuteNonQuery(string sql) &#123; return ExecuteNonQuery(sql, CommandType.Text, null); &#125; /// &lt;summary&gt; /// 对数据库执行增删改操作 /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; public int ExecuteNonQuery(string sql, CommandType commandType) &#123; return ExecuteNonQuery(sql, commandType, null); &#125; /// &lt;summary&gt; /// 对数据库执行增删改操作 /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;param name=&quot;parameters&quot;&gt;Transact-SQL 语句或存储过程的参数数组&lt;/param&gt; public int ExecuteNonQuery(string sql, CommandType commandType, SqlParameter[] parameters) &#123; int count = 0; using (SqlConnection connection = new SqlConnection(connectionString)) &#123; using (SqlCommand command = new SqlCommand(sql, connection)) &#123; command.CommandType = commandType;//设置command的CommandType为指定的CommandType //如果同时传入了参数，则添加这些参数 if (parameters != null) &#123; foreach (SqlParameter parameter in parameters) &#123; command.Parameters.Add(parameter); &#125; &#125; connection.Open();//打开数据库连接 count = command.ExecuteNonQuery(); &#125; &#125; return count;//返回执行增删改操作之后，数据库中受影响的行数 &#125; #endregion #region 以事务的模式对数据库执行增删改操作 /// &lt;summary&gt; /// 以事务的模式对数据库执行增删改操作 /// &lt;/summary&gt; /// &lt;param name=&quot;sqlArray&quot;&gt;要执行的SQL语句数组&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;param name=&quot;parametersArray&quot;&gt;Transact-SQL 语句或存储过程的参数数组&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool ExecuteNonQueryTransation(List&lt;string&gt; sqlArray, CommandType commandType, List&lt;SqlParameter[]&gt; parametersArray) &#123; bool result = false; using (SqlConnection connection = new SqlConnection(connectionString)) &#123; connection.Open();//打开数据库连接 //事务处理 using (SqlTransaction transaction = connection.BeginTransaction()) &#123; try &#123; for (int i = 0; i &lt; sqlArray.Count; i++) &#123; string sqlString = sqlArray[i]; using (SqlCommand command = new SqlCommand(sqlString, connection, transaction)) &#123; command.CommandType = commandType;//设置command的CommandType为指定的CommandType //如果同时传入了参数，则添加这些参数 if (parametersArray!=null) &#123; if (parametersArray[i] != null) &#123; foreach (SqlParameter parameter in parametersArray[i]) &#123; if (parameter.SqlValue == null) &#123; parameter.SqlValue = DBNull.Value; &#125; command.Parameters.Add(parameter); &#125; &#125; &#125; command.ExecuteNonQuery(); &#125; &#125; transaction.Commit(); //事务提交 result = true; &#125; catch (Exception ex) &#123; transaction.Rollback(); //事务回滚 return false; &#125; &#125; &#125; return result;//返回执行增删改操作之后，数据库中受影响的行数 &#125; /// &lt;summary&gt; /// 以事务的模式对数据库执行增删改操作 /// &lt;/summary&gt; /// &lt;param name=&quot;sqlArray&quot;&gt;要执行的SQL语句数组&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool ExecuteNonQueryTransation(List&lt;string&gt; sqlArray, CommandType commandType) &#123; bool result = false; using (SqlConnection connection = new SqlConnection(connectionString)) &#123; connection.Open();//打开数据库连接 //事务处理 using (SqlTransaction transaction = connection.BeginTransaction()) &#123; try &#123; for (int i = 0; i &lt; sqlArray.Count; i++) &#123; string sqlString = sqlArray[i]; using (SqlCommand command = new SqlCommand(sqlString, connection, transaction)) &#123; command.CommandType = commandType;//设置command的CommandType为指定的CommandType command.ExecuteNonQuery(); &#125; &#125; transaction.Commit(); //事务提交 result = true; &#125; catch (Exception ex) &#123; transaction.Rollback(); //事务回滚 return false; &#125; &#125; &#125; return result;//返回执行增删改操作之后，数据库中受影响的行数 &#125; #endregion #region 批量插入数据 public static void BulkInsertData(DataTable dt, string tableName, string connName) &#123; var connStr = DbConnectionManager.GetConnectionString(connName); SqlConnection conn = new SqlConnection(connStr); conn.Open(); SqlTransaction tran = conn.BeginTransaction(); SqlBulkCopy sqlBulkCopy = new SqlBulkCopy(conn, SqlBulkCopyOptions.KeepIdentity, tran);//创建SqlBulkCopy对象 // bulkCopy = new SqlBulkCopy(sqlConn, SqlBulkCopyOptions.KeepNulls, tran); try &#123; sqlBulkCopy.DestinationTableName = tableName;//目标数据库表名 sqlBulkCopy.BatchSize = 1000;//一次批量执行的数据量 sqlBulkCopy.ColumnMappings.Clear(); for (int j = 0; j &lt; dt.Columns.Count; j++) &#123; sqlBulkCopy.ColumnMappings.Add((string)dt.Columns[j].ColumnName, (string)dt.Columns[j].ColumnName);//添加要保存的列 &#125; sqlBulkCopy.WriteToServer(dt);//将源表中的数据写入数据库中目标表中 tran.Commit(); &#125; catch (Exception) &#123; tran.Rollback(); throw; &#125; finally &#123; sqlBulkCopy.Close(); conn.Close(); //GC.Collect(); &#125; &#125; #endregion&#125; 上面是核心代码，接下来是如何调用 12345678910111213141516171819public IHttpActionResult SendMailTest(string email) &#123; var result = ControllerService.Run(() =&gt; &#123; var service = MailService._ExchangeService(); Microsoft.Exchange.WebServices.Data.EmailMessage message = new Microsoft.Exchange.WebServices.Data.EmailMessage(service); message.Subject = &quot;测试标题&quot;; message.Body = new Microsoft.Exchange.WebServices.Data.MessageBody(); message.Body.BodyType = Microsoft.Exchange.WebServices.Data.BodyType.HTML; var stream = File.OpenRead(HttpRuntime.AppDomainAppPath + &quot;/HtmlTemplate/mail.html&quot;); StreamReader sr = new StreamReader(stream); string str = sr.ReadToEnd();//字符串 message.Body.Text = str; message.ToRecipients.Add(email); MailService.Instance.SendEmail(message); &#125;); return Ok(result); &#125;","tags":[{"name":"数据库","slug":"数据库","permalink":"http://tamron.club/tags/数据库/"}]},{"title":"Redis缓存技术（下）","date":"2018-04-04T10:34:34.000Z","path":"2018/04/04/Redis缓存技术（下）/","text":"继上一篇的Redis安装篇后，今天我们来研究以下C#具体操作Redis的方法 代码篇首先我们安装依赖库 代码如下： 12345678910111213141516static void Main(string[] args) &#123; var redis = ConnectionMultiplexer.Connect(&quot;Localhost:6479,password=ztredis(*)134&amp;^%xswed&quot;); var rel = &quot;&quot;; //redis.GetDatabase(0)指定数据库0； //如果不填写则默认为-1 IDatabase db = redis.GetDatabase(0); db.StringSet(&quot;key&quot;, &quot;Hello World&quot;);//把值存入key中 rel = db.StringGet(&quot;key&quot;);//读取key中的值 Console.Write(rel);//打印key中的值 DateTime time = DateTime.Now.AddDays(30); db.KeyExpire(&quot;key&quot;, time);//设置key失效时间 redis.Close();//关闭连接 redis.Dispose();//释放资源 Console.Read(); &#125; 控制台结果如下: Redis客户端如下： 以上就是我们C#写入读取Reids的简单示例","tags":[{"name":"缓存","slug":"缓存","permalink":"http://tamron.club/tags/缓存/"}]},{"title":"Redis缓存技术（上）","date":"2018-04-04T03:20:11.000Z","path":"2018/04/04/Redis缓存技术（上）/","text":"今天做的笔记是Redis缓存技术，主要是安装 详细内容参考：https://blog.csdn.net/liqingtx/article/details/60330555 个人笔记Redis是一种基于C语言开发的NoSql缓存工具，主要应用于非关系型大数据的存储查询 优势 Redis能读的速度是110000次/s,写的速度是81000次/s 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的，多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性 escape&gt; Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情（比如交集，并集，差集）。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问 基于Windows安装详细的教程在参考链接中已经给出中已经给出，下面看看我的安装步骤Redis最关键的是服务端和数据库类似，是Redis的核心所在；Redis客户端提供了Redis数据的可视化工具，并提供了一些简单的功能。我们先安装客户端。。。 一般windows应用程序，双击一直点下一步就好了，这样我们就装好客户端了；接下来是服务端 我们下载服务端程序,解压文件，双击点开文件夹 双击点开文件夹 然后我们运行run.bat，或者以运行cmd进入当前目录，执行redis-server.exe redis.conf 可以发现Redis服务端已经安装成功，端口号为6479 现在我们打开Redis客户端管理工具，点击Add New Connection 可以发现客户端连接一个缓存服务器，需要配置Name（名称）,Host（IP）,Port(端口号)，Auth(理解为密码)。我们给这个缓存库起个名字叫做LocalRedis ；Host是你要连接的缓存服务器的地址；这里我们127.0.0.1； Port在安装的时候已经给出是6479；接下来是密码，我们打开服务器的redis.conf文件 找到如下代码，requirepass后面的就是密码了 1requirepass ztredis(*)134&amp;^%xswed 现在我们就可以登录客户端了 到这里，我们的安装步骤已经完成。 关于Redis一些理解 Redis默认是开启持久化的，可根据业务需要关闭，只当作缓存来用，具体在redis.conf配置 redis.conf文件为Redis服务的配置文件，在这里可配置一些参数，比如持久化，空闲超时时限，Redis缓存库数（默认是15），缓存时间等等 Redis可以根据服务器硬件资源分配给缓存相应的内存资源，具体在redis.conf配置 Redis持久化很重要 下一篇博客会给出具体的Redis+.net的Demo代码","tags":[{"name":"缓存","slug":"缓存","permalink":"http://tamron.club/tags/缓存/"}]},{"title":"程序员的浪漫","date":"2018-04-01T10:43:06.000Z","path":"2018/04/01/程序员的浪漫/","text":"我们程序员在追求爱情方面也是非常浪漫的，利用HTML5知识自制的HTML5爱心表白动画，画面非常温馨甜蜜。 演示效果 源码地址： https://github.com/zhangdianlei/HTML5-love-you-master","tags":[{"name":"浪漫","slug":"浪漫","permalink":"http://tamron.club/tags/浪漫/"}]},{"title":"Sql脚本","date":"2018-03-30T08:39:34.000Z","path":"2018/03/30/Sql脚本/","text":"Sql脚本笔记快速查看表结构假如有一天和别人对接功能，别人给你扔过来个数据库，里面有几张表。如果手动去点击查询的话效率会非常的慢。以下Sql代码执行查询后会将表的的字段说明，类型，IsNULL等信息清楚的展示出来。当然前提是表中有字段说明，没有的话就得慢慢摸索了。。。 Sql数据库查询表结构可以通过以下代码查询 12345678910111213141516171819202122232425262728293031323334353637383940414243$ --快速查看表结构（比较全面的）SELECT CASE WHEN col.colorder = 1 THEN obj.name ELSE '' END AS 表名, col.colorder AS 序号 , col.name AS 列名 , ISNULL(ep.[value], '') AS 列说明 , t.name AS 数据类型 , col.length AS 长度 , ISNULL(COLUMNPROPERTY(col.id, col.name, 'Scale'), 0) AS 小数位数 , CASE WHEN COLUMNPROPERTY(col.id, col.name, 'IsIdentity') = 1 THEN '√' ELSE '' END AS 标识 , CASE WHEN EXISTS ( SELECT 1 FROM dbo.sysindexes si INNER JOIN dbo.sysindexkeys sik ON si.id = sik.id AND si.indid = sik.indid INNER JOIN dbo.syscolumns sc ON sc.id = sik.id AND sc.colid = sik.colid INNER JOIN dbo.sysobjects so ON so.name = si.name AND so.xtype = 'PK' WHERE sc.id = col.id AND sc.colid = col.colid ) THEN '√' ELSE '' END AS 主键 , CASE WHEN col.isnullable = 1 THEN '√' ELSE '' END AS 允许空 , ISNULL(comm.text, '') AS 默认值FROM dbo.syscolumns col LEFT JOIN dbo.systypes t ON col.xtype = t.xusertype inner JOIN dbo.sysobjects obj ON col.id = obj.id AND obj.xtype = 'U' AND obj.status &gt;= 0 LEFT JOIN dbo.syscomments comm ON col.cdefault = comm.id LEFT JOIN sys.extended_properties ep ON col.id = ep.major_id AND col.colid = ep.minor_id AND ep.name = 'MS_Description' LEFT JOIN sys.extended_properties epTwo ON obj.id = epTwo.major_id AND epTwo.minor_id = 0 AND epTwo.name = 'MS_Description'WHERE obj.name = 'NcCorporation'--表名ORDER BY col.colorder ; Sql循环插入100万条数据我们经常会用代码处理一些大数据，Sql执行效率会显得异常重要。以下代码是循环插入100万条数据，可模拟业务数据进行Sql代码调优。 首先创建Student表 12345$ create table student(sno int ,sname VARCHAR(200)) 向数据库中插入100万条随机姓名 123456789101112131415161718$ DECLARE @LN VARCHAR(300),@MN VARCHAR(200),@FN VARCHAR(200)DECLARE @LN_N INT,@MN_N INT,@FN_N INTSET @LN='李王张刘陈杨黄赵周吴徐孙朱马胡郭林何高梁郑罗宋谢唐韩曹许邓萧冯曾程蔡彭潘袁于董余苏叶吕魏蒋田杜丁沈姜范江傅钟卢汪戴崔任陆廖姚方金邱夏谭韦贾邹石熊孟秦阎薛侯雷白龙段郝孔邵史毛常万顾赖武康贺严尹钱施牛洪龚'SET @MN='德绍宗邦裕傅家積善昌世贻维孝友继绪定呈祥大正启仕执必定仲元魁家生先泽远永盛在人为任伐风树秀文光谨潭棰'SET @FN='丽云峰磊亮宏红洪量良梁良粮靓七旗奇琪谋牟弭米密祢磊类蕾肋庆情清青兴幸星刑'SET @LN_N=LEN(@LN)SET @MN_N=LEN(@MN)SET @FN_N=LEN(@FN)DECLARE @TMP VARCHAR(1000),@I INTSET @I=100WHILE @I&lt;1000000BEGIN SET @TMP=CAST(SUBSTRING(@LN,CAST(RAND()*@LN_N AS INT),1) AS VARCHAR) SET @TMP=@TMP+CAST(SUBSTRING(@MN,CAST(RAND()*@MN_N AS INT),1) AS VARCHAR) SET @TMP=@TMP+CAST(SUBSTRING(@FN,CAST(RAND()*@FN_N AS INT),1) AS VARCHAR) INSERT INTO student(sno,sname)VALUES('2005'+@I,@TMP) SET @I=@I+1end","tags":[{"name":"sql","slug":"sql","permalink":"http://tamron.club/tags/sql/"},{"name":"数据库","slug":"数据库","permalink":"http://tamron.club/tags/数据库/"}]},{"title":"Hexo常用命令","date":"2018-03-30T08:39:34.000Z","path":"2018/03/30/Hexo常用命令/","text":"Hexo常用命令笔记生成1$ hexo g 启动服务预览1$ hexo server 部署1$ hexo d 清理1$ hexo clean","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://tamron.club/tags/Hexo/"}]},{"title":"堆&栈&堆栈&队列","date":"2017-08-04T03:20:11.000Z","path":"2017/08/04/堆-栈-堆栈-队列/","text":"今天做的笔记是基本数据结构知识 个人笔记 大学里面那本严蔚敏的数据结构不厚，内容丰富，但是复杂问题的讲解方面篇幅这样就少了，比较难理解，c也不是很擅长，但是基本的思路还是有的。 简单的链表，数组，堆栈，队列，图，几个排序算法。 技术与通俗知乎上看到一个人对数据结构的看法，我觉的说的很好，在这里引用一下 如果说 Java 是自动档轿车，C 就是手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A 开到 B，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。如果你对这两件事都不感兴趣也就罢了，数据结构懂得用就好。但若你此生在编程领域还有点更高的追求，数据结构是绕不开的课题。 Java 替你做了太多事情，那么多动不动还支持范型的容器类，加上垃圾收集，会让你觉得编程很容易。但你有没有想过，那些容器类是怎么来的，以及它存在的意义是什么？最粗浅的，比如 ArrayList 这个类，你想过它的存在是多么大的福利吗——一个可以随机访问、自动增加容量的数组，这种东西 C 是没有的，要自己实现。但是，具体怎么实现呢？如果你对这种问题感兴趣，那数据结构是一定要看的。甚至，面向对象编程范式本身，就是个数据结构问题：怎么才能把数据和操作数据的方法封装到一起，来造出 class / prototype 这种东西？ 此外，很重要的一点是，数据结构也是通向各种实用算法的基石，所以学习数据结构都是提升内力的事情。 开始堆：什么是堆？又该怎么理解呢？堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵完全二叉树。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契 堆等。 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。 堆是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程。 堆是指程序运行时申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。 栈：什么是栈？又该怎么理解呢？ 栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。 栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来（先进后出） 栈(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。 堆栈：什么是堆栈？又该怎么理解呢？注意：其实堆栈本身就是栈，只是换了个抽象的名字。 堆栈的特性： 最后一个放入堆栈中的物体总是被最先拿出来， 这个特性通常称为后进先出(LIFO)队列。 堆栈中定义了一些操作。 两个最重要的是PUSH和POP。 PUSH操作在堆栈的顶部加入一 个元素。POP操作相反， 在堆栈顶部移去一个元素， 并将堆栈的大小减一。 堆、栈区别总结 ： 1.堆栈空间分配 ①栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 ②堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 2.堆栈缓存方式 ①栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。 ②堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 3.堆栈数据结构区别 ①堆（数据结构）：堆可以被看成是一棵树，如：堆排序。 ②栈（数据结构）：一种先进后出的数据结构。 队列：什么是队列？又该怎么理解呢？① 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 ②队列中没有元素时，称为空队列。 ③建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置。 ④队列采用的FIFO(first in first out)，新元素（等待进入队列的元素）总是被插入到链表的尾部，而读取的时候总是从链表的头部开始读取。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便。（先进先出） 堆、栈、队列之间的区别是？①堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。 ②栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来。（后进先出） ③队列只能在队头做删除操作,在队尾做插入操作.而栈只能在栈顶做插入和删除操作。（先进先出）","tags":[{"name":".net","slug":"net","permalink":"http://tamron.club/tags/net/"}]},{"title":"北大新任校长的十句话，全场掌声如雷","date":"2017-08-01T10:43:06.000Z","path":"2017/08/01/北大新任校长的十句话/","text":"北大信任校长的十句话，全场掌声如雷 第一句话结交两个朋友，一个是图书馆，一个是运动场。 第二句话培养两种功夫，一个是本分，一个是本事。 第三句话乐于吃两种东西，一个是吃亏，一个是吃苦 第四句话具备两种力量，一个是思想的力量，一个是利剑的凉凉 第五句话追求两个一致，一个是兴趣与事业一致，一个是爱情与婚姻一致 第六句话插上两个翅膀，一个叫理想，一个叫毅力 第七句话构建两个支柱，一个是科学，一个是人文 第八句话配备两个保健医生，一个叫运动，一个叫乐观 第九句话追求两个极致，一个是把自身的潜力发挥到极致，一个是把自己的寿命健康延长到极致 第十句话记住两个秘诀，健康的秘诀在早上，成功的秘诀在晚上","tags":[{"name":"励志","slug":"励志","permalink":"http://tamron.club/tags/励志/"}]}]