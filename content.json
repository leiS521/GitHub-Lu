[{"title":"Redis缓存技术（下）","date":"2018-04-04T10:34:34.000Z","path":"2018/04/04/Redis缓存技术（下）/","text":"继上一篇的Redis安装篇后，今天我们来研究以下C#具体操作Redis的方法 代码篇首先我们安装依赖库 代码如下： 12345678910111213141516static void Main(string[] args) &#123; var redis = ConnectionMultiplexer.Connect(&quot;Localhost:6479,password=ztredis(*)134&amp;^%xswed&quot;); var rel = &quot;&quot;; //redis.GetDatabase(0)指定数据库0； //如果不填写则默认为-1 IDatabase db = redis.GetDatabase(0); db.StringSet(&quot;key&quot;, &quot;Hello World&quot;);//把值存入key中 rel = db.StringGet(&quot;key&quot;);//读取key中的值 Console.Write(rel);//打印key中的值 DateTime time = DateTime.Now.AddDays(30); db.KeyExpire(&quot;key&quot;, time);//设置key失效时间 redis.Close();//关闭连接 redis.Dispose();//释放资源 Console.Read(); &#125; 控制台结果如下: Redis客户端如下： 以上就是我们C#写入读取Reids的简单示例","tags":[{"name":"缓存","slug":"缓存","permalink":"https://github-lu.github.io/tags/缓存/"}]},{"title":"Redis缓存技术（上）","date":"2018-04-04T03:20:11.000Z","path":"2018/04/04/Redis缓存技术（上）/","text":"今天做的笔记是Redis缓存技术，主要是安装 详细内容参考：https://blog.csdn.net/liqingtx/article/details/60330555 个人笔记Redis是一种基于C语言开发的NoSql缓存工具，主要应用于非关系型大数据的存储查询 优势 Redis能读的速度是110000次/s,写的速度是81000次/s 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的，多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性 Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情（比如交集，并集，差集）。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问 基于Windows安装详细的教程在参考链接中已经给出中已经给出，下面看看我的安装步骤Redis最关键的是服务端和数据库类似，是Redis的核心所在；Redis客户端提供了Redis数据的可视化工具，并提供了一些简单的功能。我们先安装客户端。。。 一般windows应用程序，双击一直点下一步就好了，这样我们就装好客户端了；接下来是服务端 我们下载服务端程序,解压文件，双击点开文件夹 双击点开文件夹 然后我们运行run.bat，或者以运行cmd进入当前目录，执行redis-server.exe redis.conf 可以发现Redis服务端已经安装成功，端口号为6479 现在我们打开Redis客户端管理工具，点击Add New Connection 可以发现客户端连接一个缓存服务器，需要配置Name（名称）,Host（IP）,Port(端口号)，Auth(理解为密码)。我们给这个缓存库起个名字叫做LocalRedis ；Host是你要连接的缓存服务器的地址；这里我们127.0.0.1； Port在安装的时候已经给出是6479；接下来是密码，我们打开服务器的redis.conf文件 找到如下代码，requirepass后面的就是密码了 1requirepass ztredis(*)134&amp;^%xswed 现在我们就可以登录客户端了 到这里，我们的安装步骤已经完成。 关于Redis一些理解 Redis默认是开启持久化的，可根据业务需要关闭，只当作缓存来用，具体在redis.conf配置 redis.conf文件为Redis服务的配置文件，在这里可配置一些参数，比如持久化，空闲超时时限，Redis缓存库数（默认是15），缓存时间等等 Redis可以根据服务器硬件资源分配给缓存相应的内存资源，具体在redis.conf配置 Redis持久化很重要 下一篇博客会给出具体的Redis+.net的Demo代码","tags":[{"name":"缓存","slug":"缓存","permalink":"https://github-lu.github.io/tags/缓存/"}]},{"title":"程序员的浪漫","date":"2018-04-01T10:43:06.000Z","path":"2018/04/01/程序员的浪漫/","text":"我们程序员在追求爱情方面也是非常浪漫的，利用HTML5知识自制的HTML5爱心表白动画，画面非常温馨甜蜜。 演示效果 演示地址： http://118.24.121.243/ 源码地址： https://github.com/zhangdianlei/HTML5-love-you-master","tags":[{"name":"浪漫","slug":"浪漫","permalink":"https://github-lu.github.io/tags/浪漫/"}]},{"title":"Hexo常用命令","date":"2018-03-30T08:39:34.000Z","path":"2018/03/30/Hexo常用命令/","text":"Hexo常用命令笔记生成1$ hexo g 启动服务预览1$ hexo server 部署1$ hexo d 清理1$ hexo clean","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github-lu.github.io/tags/Hexo/"}]},{"title":"Sql脚本","date":"2018-03-30T08:39:34.000Z","path":"2018/03/30/Sql脚本/","text":"Sql脚本笔记快速查看表结构假如有一天和别人对接功能，别人给你扔过来个数据库，里面有几张表。如果手动去点击查询的话效率会非常的慢。以下Sql代码执行查询后会将表的的字段说明，类型，IsNULL等信息清楚的展示出来。当然前提是表中有字段说明，没有的话就得慢慢摸索了。。。 Sql数据库查询表结构可以通过以下代码查询 12345678910111213141516171819202122232425262728293031323334353637383940414243$ --快速查看表结构（比较全面的）SELECT CASE WHEN col.colorder = 1 THEN obj.name ELSE '' END AS 表名, col.colorder AS 序号 , col.name AS 列名 , ISNULL(ep.[value], '') AS 列说明 , t.name AS 数据类型 , col.length AS 长度 , ISNULL(COLUMNPROPERTY(col.id, col.name, 'Scale'), 0) AS 小数位数 , CASE WHEN COLUMNPROPERTY(col.id, col.name, 'IsIdentity') = 1 THEN '√' ELSE '' END AS 标识 , CASE WHEN EXISTS ( SELECT 1 FROM dbo.sysindexes si INNER JOIN dbo.sysindexkeys sik ON si.id = sik.id AND si.indid = sik.indid INNER JOIN dbo.syscolumns sc ON sc.id = sik.id AND sc.colid = sik.colid INNER JOIN dbo.sysobjects so ON so.name = si.name AND so.xtype = 'PK' WHERE sc.id = col.id AND sc.colid = col.colid ) THEN '√' ELSE '' END AS 主键 , CASE WHEN col.isnullable = 1 THEN '√' ELSE '' END AS 允许空 , ISNULL(comm.text, '') AS 默认值FROM dbo.syscolumns col LEFT JOIN dbo.systypes t ON col.xtype = t.xusertype inner JOIN dbo.sysobjects obj ON col.id = obj.id AND obj.xtype = 'U' AND obj.status &gt;= 0 LEFT JOIN dbo.syscomments comm ON col.cdefault = comm.id LEFT JOIN sys.extended_properties ep ON col.id = ep.major_id AND col.colid = ep.minor_id AND ep.name = 'MS_Description' LEFT JOIN sys.extended_properties epTwo ON obj.id = epTwo.major_id AND epTwo.minor_id = 0 AND epTwo.name = 'MS_Description'WHERE obj.name = 'NcCorporation'--表名ORDER BY col.colorder ; Sql循环插入100万条数据我们经常会用代码处理一些大数据，Sql执行效率会显得异常重要。以下代码是循环插入100万条数据，可模拟业务数据进行Sql代码调优。 首先创建Student表 12345$ create table student(sno int ,sname VARCHAR(200)) 向数据库中插入100万条随机姓名 123456789101112131415161718$ DECLARE @LN VARCHAR(300),@MN VARCHAR(200),@FN VARCHAR(200)DECLARE @LN_N INT,@MN_N INT,@FN_N INTSET @LN='李王张刘陈杨黄赵周吴徐孙朱马胡郭林何高梁郑罗宋谢唐韩曹许邓萧冯曾程蔡彭潘袁于董余苏叶吕魏蒋田杜丁沈姜范江傅钟卢汪戴崔任陆廖姚方金邱夏谭韦贾邹石熊孟秦阎薛侯雷白龙段郝孔邵史毛常万顾赖武康贺严尹钱施牛洪龚'SET @MN='德绍宗邦裕傅家積善昌世贻维孝友继绪定呈祥大正启仕执必定仲元魁家生先泽远永盛在人为任伐风树秀文光谨潭棰'SET @FN='丽云峰磊亮宏红洪量良梁良粮靓七旗奇琪谋牟弭米密祢磊类蕾肋庆情清青兴幸星刑'SET @LN_N=LEN(@LN)SET @MN_N=LEN(@MN)SET @FN_N=LEN(@FN)DECLARE @TMP VARCHAR(1000),@I INTSET @I=100WHILE @I&lt;1000000BEGIN SET @TMP=CAST(SUBSTRING(@LN,CAST(RAND()*@LN_N AS INT),1) AS VARCHAR) SET @TMP=@TMP+CAST(SUBSTRING(@MN,CAST(RAND()*@MN_N AS INT),1) AS VARCHAR) SET @TMP=@TMP+CAST(SUBSTRING(@FN,CAST(RAND()*@FN_N AS INT),1) AS VARCHAR) INSERT INTO student(sno,sname)VALUES('2005'+@I,@TMP) SET @I=@I+1end","tags":[{"name":"sql","slug":"sql","permalink":"https://github-lu.github.io/tags/sql/"},{"name":"数据库","slug":"数据库","permalink":"https://github-lu.github.io/tags/数据库/"}]}]