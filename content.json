[{"title":"Redis缓存技术（上）","date":"2018-04-04T03:20:11.000Z","path":"2018/04/04/Redis缓存技术/","text":"今天做的笔记是Redis缓存技术，主要是安装 详细内容参考：https://blog.csdn.net/liqingtx/article/details/60330555 个人笔记Redis是一种基于C语言开发的NoSql缓存工具，主要应用于非关系型大数据的存储查询 优势 Redis能读的速度是110000次/s,写的速度是81000次/s 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的，多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性 Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情（比如交集，并集，差集）。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问 基于Windows安装详细的教程在参考链接中已经给出中已经给出，下面看看我的安装步骤Redis最关键的是服务端和数据库类似，是Redis的核心所在；Redis客户端提供了Redis数据的可视化工具，并提供了一些简单的功能。我们先安装客户端。。。 一般windows应用程序，双击一直点下一步就好了，这样我们就装好客户端了；接下来是服务端 我们下载服务端程序,解压文件，双击点开文件夹 双击点开文件夹 然后我们运行run.bat，或者以运行cmd进入当前目录，执行redis-server.exe redis.conf 可以发现Redis服务端已经安装成功，端口号为6479 现在我们打开Redis客户端管理工具，点击Add New Connection 可以发现客户端连接一个缓存服务器，需要配置Name（名称）,Host（IP）,Port(端口号)，Auth(理解为密码)。我们给这个缓存库起个名字叫做LocalRedis ；Host是你要连接的缓存服务器的地址；这里我们127.0.0.1； Port在安装的时候已经给出是6479；接下来是密码，我们打开服务器的redis.conf文件 找到如下代码，requirepass后面的就是密码了 1requirepass ztredis(*)134&amp;^%xswed 现在我们就可以登录客户端了 到这里，我们的安装步骤已经完成，另外提示redis.conf文件为Redis服务的配置文件，在这里可配置一些参数，比如持久化，空闲超时时限，Redis缓存库数（默认是15），缓存时间等等 关于Redis一些理解 Redis默认是开启持久化的，可根据业务需要关闭，只当作缓存来用，具体在redis.conf配置 Redis可以根据服务器硬件资源分配给缓存相应的内存资源，具体在redis.conf配置 下一篇博客会给出具体的Redis+.net的Demo代码","tags":[{"name":"缓存","slug":"缓存","permalink":"https://github-lu.github.io/tags/缓存/"}]},{"title":"异步多线程那点事","date":"2018-04-03T12:07:04.000Z","path":"2018/04/03/异步多线程那点事/","text":"异步多线程科学起源器的计算分为IO计算和CPU计算。IO计算指计算任务中以IO为主的计算模型，比如文件服务器、邮件服务器等，混合了大量的网络IO和文件IO；CPU计算指计算任务中没有或很少有IO，比如加密/解密，编码/解码，数学计算等等。 需要关心的是IO计算，一般的网络服务器程序往往伴随着大量的IO计算。提高性能的途径在于要避免等待IO 的结束，造成CPU空闲，要尽量利用硬件能力，让一个或多个IO设备与CPU并发执行。 另一方面，CPU密集的计算是我们无法控制的。如果是CPU计算出现了瓶颈，那只能给服务器增加CPU，或者增加服务器。而IO操作，实际上是空等别的硬件，这里面的优化就大有可为。 多线程虽好可不要贪杯哦首先，创建线程/进程和销毁线程/进程的代价非常高昂，尤其是在服务器采用TCP“短连接”方式或UDP方式通讯的情况下，例如，HTTP协议中，客户端发起一个连接后，发送一个请求，服务器回应了这个请求后，连接也就被关闭了。如果采用经典方式设计HTTP服务器，那么过于频繁地创建线程/销毁线程对性能造成的影响是很恶劣的。 线程还会占用内存。线程的内核对象占几M到几时M。普通的计算机上千个线程就会耗尽内存。 线程切换也会消耗时间，最终导致服务器性能急剧下降。如果客户端并发请求量很高，同一时刻有很多客户端等待服务器响应的情况下，将会有过多的线程并发执行，频繁的线程切换将用掉一部分计算能力。 对于一个需要应付同时有大量客户端并发请求的网络服务器来说，线程池是唯一的解决方案。线程池不光能够避免频繁地创建线程和销毁线程，而且能够用数目很少的线程就可以处理大量客户端并发请求。 关于网页加载的时长的Mark​据统计，用户留在加载页面的时间和用户对于该软件的了解程度成正比。一般一个陌生的产品加载时间超过5s用户就会离开页面，当然软件功能足够吸引人的话用户会再进入页面2~3次，而对于不紧急的用户熟悉的产品，用户能够给予的加载时间会稍微长些。一些大的电商网站会由于网页1秒中的等待时长年损失以亿计算。。。 自己理解 什么是同步？ 现在有A、B、C三件事，一个人首先做A，然后做B，最后做C 什么是异步 现在有A、B、C三件事，一个人首先做A，同时做B和C（也可以A,B,C同时做） 代码篇 C#5.0之后async和await出现为异步并行变成带来了很大的方便。稍后会给出具体用法 现在介绍Task,Task对象是.Net Framework 4.0之后出现的异步编程的一个重要对象。在一定程度上来说，Task对象可以理解Thread对象的一个升级产品，具体的优点体现在有返回值的委托 Task代码详解 首先我们测试异步多线程代码 12345678910111213141516171819202122232425262728System.Diagnostics.Stopwatch oTime = new System.Diagnostics.Stopwatch(); //定义一个计时对象 oTime.Start(); //开始计时 var count1 = Task&lt;int&gt;.Run(() =&gt; &#123; Thread.Sleep(3000);//模拟处理数据执行时长 return 1; &#125;); var count2 = Task&lt;int&gt;.Run(() =&gt; &#123; Thread.Sleep(3000);//模拟处理数据执行时长 return 2; &#125;); var action1 = Task.Run(() =&gt; &#123; Thread.Sleep(2000);//模拟处理数据执行时长 var sum = count1.Result + count2.Result; Console.WriteLine(&quot;count1 + count2 = &#123;0&#125;&quot;, sum); &#125;); Console.WriteLine(&quot;前面执行运算的小伙子，你执行没我快&quot;); action1.Wait(); Thread.Sleep(2000);//模拟处理数据执行时长 oTime.Stop(); Console.WriteLine(&quot;程序的运行时间：&#123;0&#125; 秒&quot;, oTime.Elapsed.TotalSeconds); return; 上述代码模拟处理数据时长10000毫秒，然后我们测试同步代码执行时长 1234567891011System.Diagnostics.Stopwatch oTime = new System.Diagnostics.Stopwatch(); //定义一个计时对象 oTime.Start(); //开始计时 var count1 = 1; var count2 = 2; var sum = count1 + count2; Thread.Sleep(10000);//模拟处理数据执行时长 Console.WriteLine(&quot;count1 + count2 = &#123;0&#125;&quot;, sum); Console.WriteLine(&quot;前面执行运算的小伙子，你执行没我快&quot;); oTime.Stop(); Console.WriteLine(&quot;程序的运行时间：&#123;0&#125; 秒&quot;, oTime.Elapsed.TotalSeconds); return; 结论：通过上述代码我们可以发现异步多线程执行在时间上能优化很多 async &amp; await 1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 计算sum/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task Sum()&#123; int count1 = 0, count2 = 0, sum = 0; var task1 = Task.Run(() =&gt; &#123; Thread.Sleep(3000); count1 = 1; &#125;); var task2 = Task.Run(() =&gt; &#123; Thread.Sleep(3000); count2 = 2; &#125;); var task3 = Task.Run(async() =&gt; &#123; Thread.Sleep(2000); await Task.WhenAll(new Task[] &#123; task1, task2 &#125;); sum = count1 + count2; Console.WriteLine(&quot;count1 + count2 = &#123;0&#125;&quot;, sum); &#125;); Thread.Sleep(2000); Console.WriteLine(&quot;前面执行运算的小伙子，你执行没我快&quot;); await Task.WhenAll(new Task[] &#123; task3 &#125;);&#125; 结论：以上就是Asnync&amp;Await的应用，有以下几点需要注意 Asnync&amp;Await是语法糖，必须在同一个方法内使用，否则IDE会有警告且没有意义 Async修饰的是一个异步方法，类型有void,Task，Task&lt;&gt; C/S项目中尽量保持主线程（UI线程）空闲，使得界面不会卡顿且操作界面元素必须是主线程 可通过线程池来控制线程上限，在服务器资源与效率上找一个平衡点 关于线程池 线程池最多管理线程数量=“处理器数 * 250”。也就是说，如果您的机器为2个2核CPU，那么CLR线程池的容量默认上限便是1000 通过线程池创建的线程默认为后台线程，优先级默认为Normal。 示例代码 12345678910111213141516static void Main(string[] args) &#123; ThreadPool.QueueUserWorkItem(new WaitCallback(ThreadMethod1), new object());//参数可选 Console.ReadKey(); &#125; public static void ThreadMethod1(object val) &#123; for (int i = 0; i &lt;= 500000000; i++) &#123; if (i % 1000000 == 0) &#123; Console.Write(Thread.CurrentThread.Name); &#125; &#125; &#125;","tags":[{"name":".net","slug":"net","permalink":"https://github-lu.github.io/tags/net/"}]},{"title":"程序员的浪漫","date":"2018-04-01T10:43:06.000Z","path":"2018/04/01/程序员的浪漫/","text":"我们程序员在追求爱情方面也是非常浪漫的，利用HTML5知识自制的HTML5爱心表白动画，画面非常温馨甜蜜。 演示效果 演示地址： http://118.24.121.243/ 源码地址： https://github.com/zhangdianlei/HTML5-love-you-master","tags":[{"name":"浪漫","slug":"浪漫","permalink":"https://github-lu.github.io/tags/浪漫/"}]},{"title":"Hexo常用命令","date":"2018-03-30T08:39:34.000Z","path":"2018/03/30/Hexo常用命令/","text":"Hexo常用命令笔记生成1$ hexo g 启动服务预览1$ hexo server 部署1$ hexo d 清理1$ hexo clean","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github-lu.github.io/tags/Hexo/"}]},{"title":"Sql脚本","date":"2018-03-30T08:39:34.000Z","path":"2018/03/30/Sql脚本/","text":"Sql脚本笔记快速查看表结构假如有一天和别人对接功能，别人给你扔过来个数据库，里面有几张表。如果手动去点击查询的话效率会非常的慢。以下Sql代码执行查询后会将表的的字段说明，类型，IsNULL等信息清楚的展示出来。当然前提是表中有字段说明，没有的话就得慢慢摸索了。。。 Sql数据库查询表结构可以通过以下代码查询 12345678910111213141516171819202122232425262728293031323334353637383940414243$ --快速查看表结构（比较全面的）SELECT CASE WHEN col.colorder = 1 THEN obj.name ELSE '' END AS 表名, col.colorder AS 序号 , col.name AS 列名 , ISNULL(ep.[value], '') AS 列说明 , t.name AS 数据类型 , col.length AS 长度 , ISNULL(COLUMNPROPERTY(col.id, col.name, 'Scale'), 0) AS 小数位数 , CASE WHEN COLUMNPROPERTY(col.id, col.name, 'IsIdentity') = 1 THEN '√' ELSE '' END AS 标识 , CASE WHEN EXISTS ( SELECT 1 FROM dbo.sysindexes si INNER JOIN dbo.sysindexkeys sik ON si.id = sik.id AND si.indid = sik.indid INNER JOIN dbo.syscolumns sc ON sc.id = sik.id AND sc.colid = sik.colid INNER JOIN dbo.sysobjects so ON so.name = si.name AND so.xtype = 'PK' WHERE sc.id = col.id AND sc.colid = col.colid ) THEN '√' ELSE '' END AS 主键 , CASE WHEN col.isnullable = 1 THEN '√' ELSE '' END AS 允许空 , ISNULL(comm.text, '') AS 默认值FROM dbo.syscolumns col LEFT JOIN dbo.systypes t ON col.xtype = t.xusertype inner JOIN dbo.sysobjects obj ON col.id = obj.id AND obj.xtype = 'U' AND obj.status &gt;= 0 LEFT JOIN dbo.syscomments comm ON col.cdefault = comm.id LEFT JOIN sys.extended_properties ep ON col.id = ep.major_id AND col.colid = ep.minor_id AND ep.name = 'MS_Description' LEFT JOIN sys.extended_properties epTwo ON obj.id = epTwo.major_id AND epTwo.minor_id = 0 AND epTwo.name = 'MS_Description'WHERE obj.name = 'NcCorporation'--表名ORDER BY col.colorder ; Sql循环插入100万条数据我们经常会用代码处理一些大数据，Sql执行效率会显得异常重要。以下代码是循环插入100万条数据，可模拟业务数据进行Sql代码调优。 首先创建Student表 12345$ create table student(sno int ,sname VARCHAR(200)) 向数据库中插入100万条随机姓名 123456789101112131415161718$ DECLARE @LN VARCHAR(300),@MN VARCHAR(200),@FN VARCHAR(200)DECLARE @LN_N INT,@MN_N INT,@FN_N INTSET @LN='李王张刘陈杨黄赵周吴徐孙朱马胡郭林何高梁郑罗宋谢唐韩曹许邓萧冯曾程蔡彭潘袁于董余苏叶吕魏蒋田杜丁沈姜范江傅钟卢汪戴崔任陆廖姚方金邱夏谭韦贾邹石熊孟秦阎薛侯雷白龙段郝孔邵史毛常万顾赖武康贺严尹钱施牛洪龚'SET @MN='德绍宗邦裕傅家積善昌世贻维孝友继绪定呈祥大正启仕执必定仲元魁家生先泽远永盛在人为任伐风树秀文光谨潭棰'SET @FN='丽云峰磊亮宏红洪量良梁良粮靓七旗奇琪谋牟弭米密祢磊类蕾肋庆情清青兴幸星刑'SET @LN_N=LEN(@LN)SET @MN_N=LEN(@MN)SET @FN_N=LEN(@FN)DECLARE @TMP VARCHAR(1000),@I INTSET @I=100WHILE @I&lt;1000000BEGIN SET @TMP=CAST(SUBSTRING(@LN,CAST(RAND()*@LN_N AS INT),1) AS VARCHAR) SET @TMP=@TMP+CAST(SUBSTRING(@MN,CAST(RAND()*@MN_N AS INT),1) AS VARCHAR) SET @TMP=@TMP+CAST(SUBSTRING(@FN,CAST(RAND()*@FN_N AS INT),1) AS VARCHAR) INSERT INTO student(sno,sname)VALUES('2005'+@I,@TMP) SET @I=@I+1end","tags":[{"name":"sql","slug":"sql","permalink":"https://github-lu.github.io/tags/sql/"},{"name":"数据库","slug":"数据库","permalink":"https://github-lu.github.io/tags/数据库/"}]}]