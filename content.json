[{"title":"测试文章","date":"2018-08-09T18:07:09.000Z","path":"2018/08/10/测试文章/","text":"","tags":[]},{"title":"23种设计模式概念","date":"2018-07-17T00:07:04.000Z","path":"2018/07/17/23种设计模式概念/","text":"1.创建型模式工厂方法（Factory Method）在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节。工厂方法模式的核心是一个抽象工厂类，各种具体工厂类通过抽象工厂类将工厂方法继承下来。如此使得客户可以只关心抽象产品和抽象工厂，完全不用理会返回的是哪一种具体产品，也不用关系它是如何被具体工厂创建的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&gt; namespace 设计模式之工厂方法模式&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 菜抽象类&gt; /// &lt;/summary&gt;&gt; public abstract class Food&gt; &#123;&gt; // 输出点了什么菜&gt; public abstract void Print();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 西红柿炒鸡蛋这道菜&gt; /// &lt;/summary&gt;&gt; public class TomatoScrambledEggs : Food&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;西红柿炒蛋好了！&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 土豆肉丝这道菜&gt; /// &lt;/summary&gt;&gt; public class ShreddedPorkWithPotatoes : Food&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;土豆肉丝好了&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 抽象工厂类&gt; /// &lt;/summary&gt;&gt; public abstract class Creator&gt; &#123;&gt; // 工厂方法&gt; public abstract Food CreateFoddFactory();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 西红柿炒蛋工厂类&gt; /// &lt;/summary&gt;&gt; public class TomatoScrambledEggsFactory:Creator&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 负责创建西红柿炒蛋这道菜&gt; /// &lt;/summary&gt;&gt; /// &lt;returns&gt;&lt;/returns&gt;&gt; public override Food CreateFoddFactory()&gt; &#123;&gt; return new TomatoScrambledEggs();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 土豆肉丝工厂类&gt; /// &lt;/summary&gt;&gt; public class ShreddedPorkWithPotatoesFactory:Creator&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 负责创建土豆肉丝这道菜&gt; /// &lt;/summary&gt;&gt; /// &lt;returns&gt;&lt;/returns&gt;&gt; public override Food CreateFoddFactory()&gt; &#123;&gt; return new ShreddedPorkWithPotatoes();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 客户端调用&gt; /// &lt;/summary&gt;&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 初始化做菜的两个工厂（）&gt; Creator shreddedPorkWithPotatoesFactory = new ShreddedPorkWithPotatoesFactory();&gt; Creator tomatoScrambledEggsFactory = new TomatoScrambledEggsFactory();&gt; &gt; // 开始做西红柿炒蛋&gt; Food tomatoScrambleEggs = tomatoScrambledEggsFactory.CreateFoddFactory();&gt; tomatoScrambleEggs.Print();&gt; &gt; //开始做土豆肉丝&gt; Food shreddedPorkWithPotatoes = shreddedPorkWithPotatoesFactory.CreateFoddFactory();&gt; shreddedPorkWithPotatoes.Print();&gt; &gt; Console.Read();&gt; &#125;&gt; &#125; &gt; &#125;&gt; 2.抽象工厂模式（Abstract Factory）抽象工厂模式的主要优点是隔离了具体类的生成，使得客户不需要知道什么被创建了。犹豫这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变这个软件的系统的行为。另外，应用抽象工厂模式符合GRASP纯虚构的模式，可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&gt; /// &lt;summary&gt;&gt; /// 下面以绝味鸭脖连锁店为例子演示下抽象工厂模式&gt; /// 因为每个地方的喜欢的口味不一样，有些地方喜欢辣点的，有些地方喜欢吃不辣点&gt; /// 客户端调用&gt; /// &lt;/summary&gt;&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 南昌工厂制作南昌的鸭脖和鸭架&gt; AbstractFactory nanChangFactory = new NanChangFactory();&gt; YaBo nanChangYabo = nanChangFactory.CreateYaBo();&gt; nanChangYabo.Print();&gt; YaJia nanChangYajia= nanChangFactory.CreateYaJia();&gt; nanChangYajia.Print();&gt; &gt; // 上海工厂制作上海的鸭脖和鸭架&gt; AbstractFactory shangHaiFactory = new ShangHaiFactory();&gt; shangHaiFactory.CreateYaBo().Print();&gt; shangHaiFactory.CreateYaJia().Print();&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 抽象工厂类，提供创建两个不同地方的鸭架和鸭脖的接口&gt; /// &lt;/summary&gt;&gt; public abstract class AbstractFactory&gt; &#123;&gt; // 抽象工厂提供创建一系列产品的接口，这里作为例子，只给出了绝味中鸭脖和鸭架的创建接口&gt; public abstract YaBo CreateYaBo();&gt; public abstract YaJia CreateYaJia();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 南昌绝味工厂负责制作南昌的鸭脖和鸭架&gt; /// &lt;/summary&gt;&gt; public class NanChangFactory : AbstractFactory&gt; &#123;&gt; // 制作南昌鸭脖&gt; public override YaBo CreateYaBo()&gt; &#123;&gt; return new NanChangYaBo();&gt; &#125;&gt; // 制作南昌鸭架&gt; public override YaJia CreateYaJia()&gt; &#123;&gt; return new NanChangYaJia();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 上海绝味工厂负责制作上海的鸭脖和鸭架&gt; /// &lt;/summary&gt;&gt; public class ShangHaiFactory : AbstractFactory&gt; &#123;&gt; // 制作上海鸭脖&gt; public override YaBo CreateYaBo()&gt; &#123;&gt; return new ShangHaiYaBo();&gt; &#125;&gt; // 制作上海鸭架&gt; public override YaJia CreateYaJia()&gt; &#123;&gt; return new ShangHaiYaJia();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 鸭脖抽象类，供每个地方的鸭脖类继承&gt; /// &lt;/summary&gt;&gt; public abstract class YaBo&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 打印方法，用于输出信息&gt; /// &lt;/summary&gt;&gt; public abstract void Print();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 鸭架抽象类，供每个地方的鸭架类继承&gt; /// &lt;/summary&gt;&gt; public abstract class YaJia&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 打印方法，用于输出信息&gt; /// &lt;/summary&gt;&gt; public abstract void Print();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 南昌的鸭脖类，因为江西人喜欢吃辣的，所以南昌的鸭脖稍微会比上海做的辣&gt; /// &lt;/summary&gt;&gt; public class NanChangYaBo : YaBo&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;南昌的鸭脖&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 上海的鸭脖没有南昌的鸭脖做的辣&gt; /// &lt;/summary&gt;&gt; public class ShangHaiYaBo : YaBo&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;上海的鸭脖&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 南昌的鸭架&gt; /// &lt;/summary&gt;&gt; public class NanChangYaJia : YaJia&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;南昌的鸭架子&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 上海的鸭架&gt; /// &lt;/summary&gt;&gt; public class ShangHaiYaJia : YaJia&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;上海的鸭架子&quot;);&gt; &#125;&gt; &#125;&gt; 3.建造者模式（Builder Pattern）建造者模式将一个复杂对象的生成责任作了很好的分配。它把构造过程放在指挥者的方法中，把装配过程放到具体建造者类中。建造者模式的产品之间都有共通点，但有时候，产品之间的差异性很大，这就需要借助工厂方法模式或抽象工厂模式。另外，如果产品的内部变化复杂，Builder的每一个子类都需要对应到不同的产品去做构建的动作、方法，这就需要定义很多个具体建造类来实现这种变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&gt; using System;&gt; using System.Collections.Generic;&gt; using System.Linq;&gt; using System.Text;&gt; &gt; &gt; /// &lt;summary&gt;&gt; /// 以组装电脑为例子&gt; /// 每台电脑的组成过程都是一致的，但是使用同样的构建过程可以创建不同的表示(即可以组装成不一样的电脑，配置不一样)&gt; /// 组装电脑的这个场景就可以应用建造者模式来设计&gt; /// &lt;/summary&gt;&gt; namespace 设计模式之建造者模式&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 客户类&gt; /// &lt;/summary&gt;&gt; class Customer&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 客户找到电脑城老板说要买电脑，这里要装两台电脑&gt; // 创建指挥者和构造者&gt; Director director = new Director();&gt; Builder b1 = new ConcreteBuilder1();&gt; Builder b2 = new ConcreteBuilder2();&gt; &gt; // 老板叫员工去组装第一台电脑&gt; director.Construct(b1);&gt; &gt; // 组装完，组装人员搬来组装好的电脑&gt; Computer computer1 = b1.GetComputer();&gt; computer1.Show();&gt; &gt; // 老板叫员工去组装第二台电脑&gt; director.Construct(b2);&gt; Computer computer2 = b2.GetComputer();&gt; computer2.Show();&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 小王和小李难道会自愿地去组装嘛，谁不想休息的，这必须有一个人叫他们去组装才会去的&gt; /// 这个人当然就是老板了，也就是建造者模式中的指挥者&gt; /// 指挥创建过程类&gt; /// &lt;/summary&gt;&gt; public class Director&gt; &#123;&gt; // 组装电脑&gt; public void Construct(Builder builder)&gt; &#123;&gt; builder.BuildPartCPU();&gt; builder.BuildPartMainBoard();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 电脑类&gt; /// &lt;/summary&gt;&gt; public class Computer&gt; &#123;&gt; // 电脑组件集合&gt; private IList&lt;string&gt; parts = new List&lt;string&gt;();&gt; &gt; // 把单个组件添加到电脑组件集合中&gt; public void Add(string part)&gt; &#123;&gt; parts.Add(part);&gt; &#125;&gt; &gt; public void Show()&gt; &#123;&gt; Console.WriteLine(&quot;电脑开始在组装.......&quot;);&gt; foreach (string part in parts)&gt; &#123;&gt; Console.WriteLine(&quot;组件&quot;+part+&quot;已装好&quot;);&gt; &#125;&gt; &gt; Console.WriteLine(&quot;电脑组装好了&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 抽象建造者，这个场景下为 &quot;组装人&quot; ，这里也可以定义为接口&gt; /// &lt;/summary&gt;&gt; public abstract class Builder&gt; &#123;&gt; // 装CPU&gt; public abstract void BuildPartCPU();&gt; // 装主板&gt; public abstract void BuildPartMainBoard();&gt; &gt; // 当然还有装硬盘，电源等组件，这里省略&gt; &gt; // 获得组装好的电脑&gt; public abstract Computer GetComputer();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 具体创建者，具体的某个人为具体创建者，例如：装机小王啊&gt; /// &lt;/summary&gt;&gt; public class ConcreteBuilder1 : Builder&gt; &#123;&gt; Computer computer = new Computer();&gt; public override void BuildPartCPU()&gt; &#123;&gt; computer.Add(&quot;CPU1&quot;);&gt; &#125;&gt; &gt; public override void BuildPartMainBoard()&gt; &#123;&gt; computer.Add(&quot;Main board1&quot;);&gt; &#125;&gt; &gt; public override Computer GetComputer()&gt; &#123;&gt; return computer;&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 具体创建者，具体的某个人为具体创建者，例如：装机小李啊&gt; /// 又装另一台电脑了&gt; /// &lt;/summary&gt;&gt; public class ConcreteBuilder2 : Builder&gt; &#123;&gt; Computer computer = new Computer();&gt; public override void BuildPartCPU()&gt; &#123;&gt; computer.Add(&quot;CPU2&quot;);&gt; &#125;&gt; &gt; public override void BuildPartMainBoard()&gt; &#123;&gt; computer.Add(&quot;Main board2&quot;);&gt; &#125;&gt; &gt; public override Computer GetComputer()&gt; &#123;&gt; return computer;&gt; &#125;&gt; &#125;&gt; &#125;&gt; 4.单例模式（Single Pattern）Singleton单例模式为一个面向对象的应用程序提供了对象唯一的访问点，不管它实现何种功能，此种模式都为设计及开发团队提供了共享的概念。然而，Singleton对象类派生子类就有很大的困难，只有在父类没有被实例化时才可以实现。值得注意的是，有些对象不可以做成Singleton，比如.net的数据库链接对象(Connection)，整个应用程序同享一个Connection对象会出现连接池溢出错误。另外，.net提供了自动废物回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是废物，自动消灭它并回收它的资源，下次利用时又会重新实例化，这种情况下应注意其状态的丢失。 12345678910111213141516171819202122232425262728&gt; /// &lt;summary&gt;&gt; /// 单例模式的实现&gt; /// &lt;/summary&gt;&gt; public class Singleton&gt; &#123;&gt; // 定义一个静态变量来保存类的实例&gt; private static Singleton uniqueInstance;&gt; &gt; // 定义私有构造函数，使外界不能创建该类实例&gt; private Singleton()&gt; &#123;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点&gt; /// &lt;/summary&gt;&gt; /// &lt;returns&gt;&lt;/returns&gt;&gt; public static Singleton GetInstance()&gt; &#123;&gt; // 如果类的实例不存在则创建，否则直接返回&gt; if (uniqueInstance == null)&gt; &#123;&gt; uniqueInstance = new Singleton();&gt; &#125;&gt; return uniqueInstance;&gt; &#125;&gt; &#125;&gt; 5.原型模式（Protype Pattern）原型模式得到了广泛的应用，特别是在创建对象成本较大的情况下(初始化需占用较长时间，占用太多CPU资源或网络资源。比如通过Webservice或DCOM创建对象，或者创建对象要装载大文件)，系统如果需要重复利用，新的对象可以通过原型模式对已有对象的属性进行复制并稍作修改来取得。另外，如果系统要保存对象的状态而对象的状态变化很小，或者对象本身占内存不大的时候，也可以用原型模式配合备忘录模式来应用。相反地，如果对象的状态变化很大，或者对象占用内存很大，那么采用状态模式会比原型模式更好。原型模式的缺点是在实现深层复制时需要编写复杂的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt; ///火影忍者中鸣人的影分身和孙悟空的的变都是原型模式&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 孙悟空 原型&gt; MonkeyKingPrototype prototypeMonkeyKing = new ConcretePrototype(&quot;MonkeyKing&quot;);&gt; &gt; // 变一个&gt; MonkeyKingPrototype cloneMonkeyKing = prototypeMonkeyKing.Clone() as ConcretePrototype;&gt; Console.WriteLine(&quot;Cloned1:\\t&quot;+cloneMonkeyKing.Id);&gt; &gt; // 变两个&gt; MonkeyKingPrototype cloneMonkeyKing2 = prototypeMonkeyKing.Clone() as ConcretePrototype;&gt; Console.WriteLine(&quot;Cloned2:\\t&quot; + cloneMonkeyKing2.Id);&gt; Console.ReadLine();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 孙悟空原型&gt; /// &lt;/summary&gt;&gt; public abstract class MonkeyKingPrototype&gt; &#123;&gt; public string Id &#123; get; set; &#125;&gt; public MonkeyKingPrototype(string id)&gt; &#123;&gt; this.Id = id;&gt; &#125;&gt; &gt; // 克隆方法，即孙大圣说“变”&gt; public abstract MonkeyKingPrototype Clone();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 创建具体原型&gt; /// &lt;/summary&gt;&gt; public class ConcretePrototype : MonkeyKingPrototype&gt; &#123;&gt; public ConcretePrototype(string id)&gt; : base(id)&gt; &#123; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 浅拷贝&gt; /// &lt;/summary&gt;&gt; /// &lt;returns&gt;&lt;/returns&gt;&gt; public override MonkeyKingPrototype Clone()&gt; &#123;&gt; // 调用MemberwiseClone方法实现的是浅拷贝，另外还有深拷贝&gt; return (MonkeyKingPrototype)this.MemberwiseClone();&gt; &#125;&gt; &#125;&gt; 6.结构型模式适配器模式（Adapter Pattern）适配器模式可以将一个类的接口和另一个类的接口匹配起来，使用的前提是你不能或不想修改原来的适配器母接口(adaptee)。例如，你向第三方购买了一些类、控件，但是没有源程序，这时，使用适配器模式，你可以统一对象访问接口。但客户调用可能需要变动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&gt; using System;&gt; /// 这里以插座和插头的例子来诠释适配器模式&gt; /// 现在我们买的电器插头是2个孔，但是我们买的插座只有3个孔的&gt; /// 这是我们想把电器插在插座上的话就需要一个电适配器&gt; namespace 设计模式之适配器模式&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 客户端，客户想要把2个孔的插头 转变成三个孔的插头，这个转变交给适配器就好&gt; /// 既然适配器需要完成这个功能，所以它必须同时具体2个孔插头和三个孔插头的特征&gt; /// &lt;/summary&gt;&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 现在客户端可以通过电适配要使用2个孔的插头了&gt; IThreeHole threehole = new PowerAdapter();&gt; threehole.Request();&gt; Console.ReadLine();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 三个孔的插头，也就是适配器模式中的目标角色&gt; /// &lt;/summary&gt;&gt; public interface IThreeHole&gt; &#123;&gt; void Request();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 两个孔的插头，源角色——需要适配的类&gt; /// &lt;/summary&gt;&gt; public abstract class TwoHole&gt; &#123;&gt; public void SpecificRequest()&gt; &#123;&gt; Console.WriteLine(&quot;我是两个孔的插头&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 适配器类，接口要放在类的后面&gt; /// 适配器类提供了三个孔插头的行为，但其本质是调用两个孔插头的方法&gt; /// &lt;/summary&gt;&gt; public class PowerAdapter:TwoHole,IThreeHole&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 实现三个孔插头接口方法&gt; /// &lt;/summary&gt;&gt; public void Request()&gt; &#123;&gt; // 调用两个孔插头方法&gt; this.SpecificRequest();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 7.桥接模式（Bridge Pattern）桥接模式可以从接口中分离实现功能，使得设计更具扩展性，这样，客户调用方法时根本不需要知道实现的细节。桥接模式减少了子类，假设程序要在2个操作系统中处理6种图像格式，纯粹的继承就需要(2*6)12个子类，而应用桥接模式，只需要(2+6)8个子类。它使得代码更清洁，生成的执行程序文件更小。 桥接模式的缺陷是抽象类与实现类的双向连接使得运行速度减慢。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt; /// &lt;summary&gt;&gt; /// 抽象概念中的遥控器，扮演抽象化角色&gt; /// &lt;/summary&gt;&gt; public class RemoteControl&gt; &#123;&gt; // 字段&gt; private TV implementor;&gt; &gt; // 属性&gt; public TV Implementor&gt; &#123;&gt; get &#123; return implementor; &#125;&gt; set &#123; implementor = value; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 开电视机，这里抽象类中不再提供实现了，而是调用实现类中的实现&gt; /// &lt;/summary&gt;&gt; public virtual void On()&gt; &#123;&gt; implementor.On();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 关电视机&gt; /// &lt;/summary&gt;&gt; public virtual void Off()&gt; &#123;&gt; implementor.Off();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 换频道&gt; /// &lt;/summary&gt;&gt; public virtual void SetChannel()&gt; &#123;&gt; implementor.tuneChannel();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 具体遥控器&gt; /// &lt;/summary&gt;&gt; public class ConcreteRemote : RemoteControl&gt; &#123;&gt; public override void SetChannel()&gt; &#123;&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; base.SetChannel();&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; &#125;&gt; &#125;&gt; 8.组合模式（Composite Pattern）组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，使得增加新部件也更容易，因为它让客户忽略了层次的不同性，而它的结构又是动态的，提供了对象管理的灵活接口。组合模式对于树结构的控制有着神奇的功效，例如在人力资源系统的组织架构及ERP系统的BOM设计中，组合模式得到重点应用。组合模式的缺陷是使得设计变得更加抽象。对象的商业规则如果很复杂，则实现组合模式具有很大挑战性，并且，不是所有的方法都与叶部件子类有关联。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&gt; // 通过一些简单图形以及一些复杂图形构建图形树来演示组合模式&gt; // 客户端调用&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; ComplexGraphics complexGraphics = new ComplexGraphics(&quot;一个复杂图形和两条线段组成的复杂图形&quot;);&gt; complexGraphics.Add(new Line(&quot;线段A&quot;));&gt; ComplexGraphics CompositeCG = new ComplexGraphics(&quot;一个圆和一条线组成的复杂图形&quot;);&gt; CompositeCG.Add(new Circle(&quot;圆&quot;));&gt; CompositeCG.Add(new Circle(&quot;线段B&quot;));&gt; complexGraphics.Add(CompositeCG);&gt; Line l = new Line(&quot;线段C&quot;);&gt; complexGraphics.Add(l);&gt; &gt; // 显示复杂图形的画法&gt; Console.WriteLine(&quot;复杂图形的绘制如下：&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; complexGraphics.Draw();&gt; Console.WriteLine(&quot;复杂图形绘制完成&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; Console.WriteLine();&gt; &gt; // 移除一个组件再显示复杂图形的画法&gt; complexGraphics.Remove(l);&gt; Console.WriteLine(&quot;移除线段C后，复杂图形的绘制如下：&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; complexGraphics.Draw();&gt; Console.WriteLine(&quot;复杂图形绘制完成&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 图形抽象类，&gt; /// &lt;/summary&gt;&gt; public abstract class Graphics&gt; &#123;&gt; public string Name &#123; get; set; &#125;&gt; public Graphics(string name)&gt; &#123;&gt; this.Name = name;&gt; &#125;&gt; &gt; public abstract void Draw();&gt; public abstract void Add(Graphics g);&gt; public abstract void Remove(Graphics g);&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 简单图形类——线&gt; /// &lt;/summary&gt;&gt; public class Line : Graphics&gt; &#123;&gt; public Line(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; // 重写父类抽象方法&gt; public override void Draw()&gt; &#123;&gt; Console.WriteLine(&quot;画 &quot; + Name);&gt; &#125;&gt; // 因为简单图形在添加或移除其他图形，所以简单图形Add或Remove方法没有任何意义&gt; // 如果客户端调用了简单图形的Add或Remove方法将会在运行时抛出异常&gt; // 我们可以在客户端捕获该类移除并处理&gt; public override void Add(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Line添加其他图形&quot;);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Line移除其他图形&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 简单图形类——圆&gt; /// &lt;/summary&gt;&gt; public class Circle : Graphics&gt; &#123;&gt; public Circle(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; // 重写父类抽象方法&gt; public override void Draw()&gt; &#123;&gt; Console.WriteLine(&quot;画 &quot; + Name);&gt; &#125;&gt; &gt; public override void Add(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Circle添加其他图形&quot;);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Circle移除其他图形&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 复杂图形，由一些简单图形组成,这里假设该复杂图形由一个圆两条线组成的复杂图形&gt; /// &lt;/summary&gt;&gt; public class ComplexGraphics : Graphics&gt; &#123;&gt; private List&lt;Graphics&gt; complexGraphicsList = new List&lt;Graphics&gt;();&gt; &gt; public ComplexGraphics(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 复杂图形的画法&gt; /// &lt;/summary&gt;&gt; public override void Draw()&gt; &#123; &gt; foreach (Graphics g in complexGraphicsList)&gt; &#123;&gt; g.Draw();&gt; &#125;&gt; &#125;&gt; &gt; public override void Add(Graphics g)&gt; &#123;&gt; complexGraphicsList.Add(g);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; complexGraphicsList.Remove(g);&gt; &#125;&gt; &#125;&gt; 9.装饰模式（Decorator Pattern）装饰模式提供了比静态继承更好的柔韧性，它允许开发一系列的功能类用来代替增加对象的行为，这既不会污染原来对象的源码，还能使代码更容易编写，使类更具扩展性，因为变化都是由新的装饰类来完成。还可以建立连接的装饰对象关系链。需要注意的是，装饰链不宜过长。装饰链太长会使系统花费较长时间用于初始化对象，同时信息在链中的传递也会浪费太多的时间。这个情况好比物品包装，包了一层又一层，大包套小包。另外，如果原来的对象接口发生变化，它所以的装饰类都要修改以匹配它的变化。派生子类会影响对象的内部，而一个Decorator只会影响对象的外表。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&gt; /// &lt;summary&gt;&gt; /// 手机抽象类，即装饰者模式中的抽象组件类&gt; /// &lt;/summary&gt;&gt; public abstract class Phone&gt; &#123;&gt; public abstract void Print();&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 苹果手机，即装饰着模式中的具体组件类&gt; /// &lt;/summary&gt;&gt; public class ApplePhone:Phone&gt; &#123;&gt; /// &lt;summary&gt;&gt; /// 重写基类方法&gt; /// &lt;/summary&gt;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;开始执行具体的对象——苹果手机&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 装饰抽象类,要让装饰完全取代抽象组件，所以必须继承自Photo&gt; /// &lt;/summary&gt;&gt; public abstract class Decorator:Phone&gt; &#123;&gt; private Phone phone;&gt; &gt; public Decorator(Phone p)&gt; &#123;&gt; this.phone = p;&gt; &#125;&gt; &gt; public override void Print()&gt; &#123;&gt; if (phone != null)&gt; &#123;&gt; phone.Print();&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 贴膜，即具体装饰者&gt; /// &lt;/summary&gt;&gt; public class Sticker : Decorator&gt; &#123;&gt; public Sticker(Phone p)&gt; : base(p)&gt; &#123; &gt; &#125;&gt; &gt; public override void Print()&gt; &#123;&gt; base.Print();&gt; &gt; // 添加新的行为&gt; AddSticker(); &gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 新的行为方法&gt; /// &lt;/summary&gt;&gt; public void AddSticker()&gt; &#123;&gt; Console.WriteLine(&quot;现在苹果手机有贴膜了&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 手机挂件&gt; /// &lt;/summary&gt;&gt; public class Accessories : Decorator&gt; &#123;&gt; public Accessories(Phone p)&gt; : base(p)&gt; &#123;&gt; &#125;&gt; &gt; public override void Print()&gt; &#123;&gt; base.Print();&gt; &gt; // 添加新的行为&gt; AddAccessories(); &gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 新的行为方法&gt; /// &lt;/summary&gt;&gt; public void AddAccessories()&gt; &#123;&gt; Console.WriteLine(&quot;现在苹果手机有漂亮的挂件了&quot;);&gt; &#125;&gt; &#125;&gt; 10.外观模式（Façade Pattern）外观模式提供了一个简单且公用的接口去处理复杂的子系统，并且没有减少子系统的功能。它遮蔽了子系统的复杂性，避免了客户与子系统直接链接，它也减少了子系统与子系统间的连接，每个子系统都有它的Facade模式，每个子系统采用Facade模式去访问其他子系统。外观模式的劣势就是限制了客户的自由，减少了可变性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&gt; // 通过一些简单图形以及一些复杂图形构建图形树来演示组合模式&gt; // 客户端调用&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; ComplexGraphics complexGraphics = new ComplexGraphics(&quot;一个复杂图形和两条线段组成的复杂图形&quot;);&gt; complexGraphics.Add(new Line(&quot;线段A&quot;));&gt; ComplexGraphics CompositeCG = new ComplexGraphics(&quot;一个圆和一条线组成的复杂图形&quot;);&gt; CompositeCG.Add(new Circle(&quot;圆&quot;));&gt; CompositeCG.Add(new Circle(&quot;线段B&quot;));&gt; complexGraphics.Add(CompositeCG);&gt; Line l = new Line(&quot;线段C&quot;);&gt; complexGraphics.Add(l);&gt; &gt; // 显示复杂图形的画法&gt; Console.WriteLine(&quot;复杂图形的绘制如下：&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; complexGraphics.Draw();&gt; Console.WriteLine(&quot;复杂图形绘制完成&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; Console.WriteLine();&gt; &gt; // 移除一个组件再显示复杂图形的画法&gt; complexGraphics.Remove(l);&gt; Console.WriteLine(&quot;移除线段C后，复杂图形的绘制如下：&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; complexGraphics.Draw();&gt; Console.WriteLine(&quot;复杂图形绘制完成&quot;);&gt; Console.WriteLine(&quot;---------------------&quot;);&gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 图形抽象类，&gt; /// &lt;/summary&gt;&gt; public abstract class Graphics&gt; &#123;&gt; public string Name &#123; get; set; &#125;&gt; public Graphics(string name)&gt; &#123;&gt; this.Name = name;&gt; &#125;&gt; &gt; public abstract void Draw();&gt; public abstract void Add(Graphics g);&gt; public abstract void Remove(Graphics g);&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 简单图形类——线&gt; /// &lt;/summary&gt;&gt; public class Line : Graphics&gt; &#123;&gt; public Line(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; // 重写父类抽象方法&gt; public override void Draw()&gt; &#123;&gt; Console.WriteLine(&quot;画 &quot; + Name);&gt; &#125;&gt; // 因为简单图形在添加或移除其他图形，所以简单图形Add或Remove方法没有任何意义&gt; // 如果客户端调用了简单图形的Add或Remove方法将会在运行时抛出异常&gt; // 我们可以在客户端捕获该类移除并处理&gt; public override void Add(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Line添加其他图形&quot;);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Line移除其他图形&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 简单图形类——圆&gt; /// &lt;/summary&gt;&gt; public class Circle : Graphics&gt; &#123;&gt; public Circle(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; // 重写父类抽象方法&gt; public override void Draw()&gt; &#123;&gt; Console.WriteLine(&quot;画 &quot; + Name);&gt; &#125;&gt; &gt; public override void Add(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Circle添加其他图形&quot;);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; throw new Exception(&quot;不能向简单图形Circle移除其他图形&quot;);&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 复杂图形，由一些简单图形组成,这里假设该复杂图形由一个圆两条线组成的复杂图形&gt; /// &lt;/summary&gt;&gt; public class ComplexGraphics : Graphics&gt; &#123;&gt; private List&lt;Graphics&gt; complexGraphicsList = new List&lt;Graphics&gt;();&gt; &gt; public ComplexGraphics(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 复杂图形的画法&gt; /// &lt;/summary&gt;&gt; public override void Draw()&gt; &#123; &gt; foreach (Graphics g in complexGraphicsList)&gt; &#123;&gt; g.Draw();&gt; &#125;&gt; &#125;&gt; &gt; public override void Add(Graphics g)&gt; &#123;&gt; complexGraphicsList.Add(g);&gt; &#125;&gt; public override void Remove(Graphics g)&gt; &#123;&gt; complexGraphicsList.Remove(g);&gt; &#125;&gt; &#125;&gt; 11.享元模式（Flyweight Pattern）Flyweight模式需要你认真考虑如何能细化对象，以减少处理的对象数量，从而减少存留对象在内存或其他存储设备中的占用量。然而，此模式需要维护大量对象的外部状态，如果外部状态的数据量大，传递、查找、计算这些恶数据会变得非常复杂。当外部和内部的状态很难分清时，不宜采用flyweight模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&gt; /// &lt;summary&gt;&gt; /// 客户端调用&gt; /// &lt;/summary&gt;&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 定义外部状态，例如字母的位置等信息&gt; int externalstate = 10;&gt; // 初始化享元工厂&gt; FlyweightFactory factory = new FlyweightFactory();&gt; &gt; // 判断是否已经创建了字母A，如果已经创建就直接使用创建的对象A&gt; Flyweight fa = factory.GetFlyweight(&quot;A&quot;);&gt; if (fa != null)&gt; &#123;&gt; // 把外部状态作为享元对象的方法调用参数&gt; fa.Operation(--externalstate);&gt; &#125;&gt; // 判断是否已经创建了字母B&gt; Flyweight fb = factory.GetFlyweight(&quot;B&quot;);&gt; if (fb != null)&gt; &#123;&gt; fb.Operation(--externalstate);&gt; &#125;&gt; // 判断是否已经创建了字母C&gt; Flyweight fc = factory.GetFlyweight(&quot;C&quot;);&gt; if (fc != null)&gt; &#123;&gt; fc.Operation(--externalstate);&gt; &#125;&gt; // 判断是否已经创建了字母D&gt; Flyweight fd= factory.GetFlyweight(&quot;D&quot;);&gt; if (fd != null)&gt; &#123;&gt; fd.Operation(--externalstate);&gt; &#125;&gt; else&gt; &#123;&gt; Console.WriteLine(&quot;驻留池中不存在字符串D&quot;);&gt; // 这时候就需要创建一个对象并放入驻留池中&gt; ConcreteFlyweight d = new ConcreteFlyweight(&quot;D&quot;);&gt; factory.flyweights.Add(&quot;D&quot;, d);&gt; &#125;&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 享元工厂，负责创建和管理享元对象&gt; /// &lt;/summary&gt;&gt; public class FlyweightFactory&gt; &#123;&gt; // 最好使用泛型Dictionary&lt;string,Flyweighy&gt;&gt; //public Dictionary&lt;string, Flyweight&gt; flyweights = new Dictionary&lt;string, Flyweight&gt;();&gt; public Hashtable flyweights = new Hashtable();&gt; &gt; public FlyweightFactory()&gt; &#123;&gt; flyweights.Add(&quot;A&quot;, new ConcreteFlyweight(&quot;A&quot;));&gt; flyweights.Add(&quot;B&quot;, new ConcreteFlyweight(&quot;B&quot;));&gt; flyweights.Add(&quot;C&quot;, new ConcreteFlyweight(&quot;C&quot;));&gt; &#125;&gt; &gt; public Flyweight GetFlyweight(string key)&gt; &#123;&gt; // 更好的实现如下&gt; //Flyweight flyweight = flyweights[key] as Flyweight;&gt; //if (flyweight == null)&gt; //&#123;&gt; // Console.WriteLine(&quot;驻留池中不存在字符串&quot; + key);&gt; // flyweight = new ConcreteFlyweight(key);&gt; //&#125;&gt; //return flyweight;&gt; return flyweights[key] as Flyweight;&gt; &#125;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 抽象享元类，提供具体享元类具有的方法&gt; /// &lt;/summary&gt;&gt; public abstract class Flyweight&gt; &#123;&gt; public abstract void Operation(int extrinsicstate);&gt; &#125;&gt; &gt; // 具体的享元对象，这样我们不把每个字母设计成一个单独的类了，而是作为把共享的字母作为享元对象的内部状态&gt; public class ConcreteFlyweight : Flyweight&gt; &#123;&gt; // 内部状态&gt; private string intrinsicstate ;&gt; &gt; // 构造函数&gt; public ConcreteFlyweight(string innerState)&gt; &#123;&gt; this.intrinsicstate = innerState;&gt; &#125;&gt; &gt; /// &lt;summary&gt;&gt; /// 享元类的实例方法&gt; /// &lt;/summary&gt;&gt; /// &lt;param name=&quot;extrinsicstate&quot;&gt;外部状态&lt;/param&gt;&gt; public override void Operation(int extrinsicstate)&gt; &#123;&gt; Console.WriteLine(&quot;具体实现类: intrinsicstate &#123;0&#125;, extrinsicstate &#123;1&#125;&quot;, intrinsicstate, extrinsicstate);&gt; &#125;&gt; &#125;&gt; 12.代理模式（Proxy Pattern）当对象在远程机器上，要通过网络来生成时，速度可能会慢，此时应用Remote Proxy模式，可以掩蔽对象由网络生成的过程，系统的速度会加快；对于大图片的加载，Virtual Proxy模式可以让加载在后台进行，前台用的Proxy对象使得整体运行速度得到优化；Protect Proxy可以验证对真实对象的引用权限。代理模式的缺陷是请求的处理速度会变慢，并且实现Proxy模式需要额外的工作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt; // 客户端调用&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 创建一个代理对象并发出请求&gt; Person proxy = new Friend();&gt; proxy.BuyProduct();&gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; // 抽象主题角色&gt; public abstract class Person&gt; &#123;&gt; public abstract void BuyProduct();&gt; &#125;&gt; &gt; //真实主题角色&gt; public class RealBuyPerson : Person&gt; &#123;&gt; public override void BuyProduct()&gt; &#123;&gt; Console.WriteLine(&quot;帮我买一个IPhone和一台苹果电脑&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 代理角色&gt; public class Friend:Person&gt; &#123;&gt; // 引用真实主题实例&gt; RealBuyPerson realSubject;&gt; &gt; public override void BuyProduct()&gt; &#123;&gt; Console.WriteLine(&quot;通过代理类访问真实实体对象的方法&quot;);&gt; if (realSubject == null)&gt; &#123;&gt; realSubject = new RealBuyPerson();&gt; &#125;&gt; &gt; this.PreBuyProduct();&gt; // 调用真实主题方法&gt; realSubject.BuyProduct();&gt; this.PostBuyProduct();&gt; &#125;&gt; &gt; // 代理角色执行的一些操作&gt; public void PreBuyProduct()&gt; &#123;&gt; // 可能不知一个朋友叫这位朋友带东西，首先这位出国的朋友要对每一位朋友要带的东西列一个清单等&gt; Console.WriteLine(&quot;我怕弄糊涂了，需要列一张清单，张三：要带相机，李四：要带Iphone...........&quot;);&gt; &#125;&gt; &gt; // 买完东西之后，代理角色需要针对每位朋友需要的对买来的东西进行分类&gt; public void PostBuyProduct()&gt; &#123;&gt; Console.WriteLine(&quot;终于买完了，现在要对东西分一下，相机是张三的；Iphone是李四的..........&quot;);&gt; &#125;&gt; &#125;&gt; 13.行为型模式职责链模式（Chain of Responsibility）责任链模式可以减少对象的连接，为对象责任分配增加了很大的灵活性。该模式允许把一组类作为一个类来使用，并且在类的组合中，一个类的事件可以发送到另一个类并由其处理。责任链模式通常应用与图形用户界面中，窗体的部件可能会包含其他几个小部件，就如同Windows窗体应用程序中，控件中又可以放置其他控件，控件边界会决定是否处理事件，或者将事件传递给父控件来处理。另外，责任链还会以树状出现，这样，一个事件可以传给多个类，或者，多个类的信息可以提交到一个类。树状责任链能够提供更灵活的技巧，但缺点是信息在树中容易迷失。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&gt; namespace ChainofResponsibility&gt; &#123;&gt; // 采购请求&gt; public class PurchaseRequest&gt; &#123;&gt; // 金额&gt; public double Amount &#123; get; set; &#125;&gt; // 产品名字&gt; public string ProductName &#123; get; set; &#125;&gt; public PurchaseRequest(double amount, string productName)&gt; &#123;&gt; Amount = amount;&gt; ProductName = productName;&gt; &#125;&gt; &#125;&gt; &gt; // 审批人,Handler&gt; public abstract class Approver&gt; &#123;&gt; public Approver NextApprover &#123; get; set; &#125;&gt; public string Name &#123; get; set; &#125;&gt; public Approver(string name)&gt; &#123;&gt; this.Name = name;&gt; &#125;&gt; public abstract void ProcessRequest(PurchaseRequest request);&gt; &#125;&gt; &gt; // ConcreteHandler&gt; public class Manager : Approver&gt; &#123;&gt; public Manager(string name)&gt; : base(name)&gt; &#123; &#125;&gt; &gt; public override void ProcessRequest(PurchaseRequest request)&gt; &#123;&gt; if (request.Amount &lt; 10000.0)&gt; &#123;&gt; Console.WriteLine(&quot;&#123;0&#125;-&#123;1&#125; approved the request of purshing &#123;2&#125;&quot;, this, Name, request.ProductName);&gt; &#125;&gt; else if (NextApprover != null)&gt; &#123;&gt; NextApprover.ProcessRequest(request);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; // ConcreteHandler,副总&gt; public class VicePresident : Approver&gt; &#123;&gt; public VicePresident(string name)&gt; : base(name)&gt; &#123; &gt; &#125;&gt; public override void ProcessRequest(PurchaseRequest request)&gt; &#123;&gt; if (request.Amount &lt; 25000.0)&gt; &#123;&gt; Console.WriteLine(&quot;&#123;0&#125;-&#123;1&#125; approved the request of purshing &#123;2&#125;&quot;, this, Name, request.ProductName);&gt; &#125;&gt; else if (NextApprover != null)&gt; &#123;&gt; NextApprover.ProcessRequest(request);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; // ConcreteHandler，总经理&gt; public class President :Approver&gt; &#123;&gt; public President(string name)&gt; : base(name)&gt; &#123; &#125;&gt; public override void ProcessRequest(PurchaseRequest request)&gt; &#123;&gt; if (request.Amount &lt; 100000.0)&gt; &#123;&gt; Console.WriteLine(&quot;&#123;0&#125;-&#123;1&#125; approved the request of purshing &#123;2&#125;&quot;, this, Name, request.ProductName);&gt; &#125;&gt; else&gt; &#123;&gt; Console.WriteLine(&quot;Request需要组织一个会议讨论&quot;);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; PurchaseRequest requestTelphone = new PurchaseRequest(4000.0, &quot;Telphone&quot;);&gt; PurchaseRequest requestSoftware = new PurchaseRequest(10000.0, &quot;Visual Studio&quot;);&gt; PurchaseRequest requestComputers = new PurchaseRequest(40000.0, &quot;Computers&quot;);&gt; &gt; Approver manager = new Manager(&quot;LearningHard&quot;);&gt; Approver Vp = new VicePresident(&quot;Tony&quot;);&gt; Approver Pre = new President(&quot;BossTom&quot;);&gt; &gt; // 设置责任链&gt; manager.NextApprover = Vp;&gt; Vp.NextApprover = Pre;&gt; &gt; // 处理请求&gt; manager.ProcessRequest(requestTelphone);&gt; manager.ProcessRequest(requestSoftware);&gt; manager.ProcessRequest(requestComputers);&gt; Console.ReadLine();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 14.命令模式（Command Pattern）命令模式分离了接受请求的对象与实现处理请求工作的对象，这样，已经存在的类可以保持不变，使得增加新类的工作更简单。例如，很多软件的宏命令就提高了系统的自动化程度。命令模式还可以分离用户界面和业务对象，降低系统的耦合度。但是，命令模式最主要的缺陷就是，类的数量增加了，系统变得更复杂，程序的调试工作也相应变得困难。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&gt; // 教官，负责调用命令对象执行请求&gt; public class Invoke&gt; &#123;&gt; public Command _command;&gt; &gt; public Invoke(Command command)&gt; &#123;&gt; this._command = command;&gt; &#125;&gt; &gt; public void ExecuteCommand()&gt; &#123;&gt; _command.Action();&gt; &#125;&gt; &#125;&gt; &gt; // 命令抽象类&gt; public abstract class Command &gt; &#123;&gt; // 命令应该知道接收者是谁，所以有Receiver这个成员变量&gt; protected Receiver _receiver;&gt; &gt; public Command(Receiver receiver)&gt; &#123;&gt; this._receiver = receiver;&gt; &#125;&gt; &gt; // 命令执行方法&gt; public abstract void Action();&gt; &#125;&gt; &gt; // &gt; public class ConcreteCommand :Command&gt; &#123;&gt; public ConcreteCommand(Receiver receiver)&gt; : base(receiver)&gt; &#123; &gt; &#125;&gt; &gt; public override void Action()&gt; &#123;&gt; // 调用接收的方法，因为执行命令的是学生&gt; _receiver.Run1000Meters();&gt; &#125;&gt; &#125;&gt; &gt; // 命令接收者——学生&gt; public class Receiver&gt; &#123;&gt; public void Run1000Meters()&gt; &#123;&gt; Console.WriteLine(&quot;跑1000米&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 院领导&gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 初始化Receiver、Invoke和Command&gt; Receiver r = new Receiver();&gt; Command c = new ConcreteCommand(r);&gt; Invoke i = new Invoke(c);&gt; &gt; // 院领导发出命令&gt; i.ExecuteCommand();&gt; &#125;&gt; &#125;&gt; 15.解释器模式（Interpreter Pattern）解释器模式的作用很强大，它使得改变和扩展文法变得容易，实现文法也变得简单明了，很多编译器，包括文本编辑器、网页浏览器及VRML都应用解释器模式。解释器模式的缺陷就是，因为文句会分析成树结构，解释器需要递归访问它，所以效率会受影响。这种情况开发人员会有所体会，编译整个工程源码耗费时间都比较长。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255&gt; namespace InterpreterPattern&gt; &#123;&gt; // 抽象表达式&gt; public abstract class Expression&gt; &#123;&gt; protected Dictionary&lt;string, int&gt; table = new Dictionary&lt;string, int&gt;(9);&gt; &gt; protected Expression()&gt; &#123;&gt; table.Add(&quot;一&quot;, 1);&gt; table.Add(&quot;二&quot;, 2);&gt; table.Add(&quot;三&quot;, 3);&gt; table.Add(&quot;四&quot;, 4);&gt; table.Add(&quot;五&quot;, 5);&gt; table.Add(&quot;六&quot;, 6);&gt; table.Add(&quot;七&quot;, 7);&gt; table.Add(&quot;八&quot;, 8);&gt; table.Add(&quot;九&quot;, 9);&gt; &#125;&gt; &gt; public virtual void Interpreter(Context context)&gt; &#123;&gt; if (context.Statement.Length == 0)&gt; &#123;&gt; return;&gt; &#125;&gt; &gt; foreach (string key in table.Keys)&gt; &#123;&gt; int value = table[key];&gt; &gt; if (context.Statement.EndsWith(key + GetPostFix()))&gt; &#123;&gt; context.Data += value * this.Multiplier();&gt; context.Statement = context.Statement.Substring(0, context.Statement.Length - this.GetLength());&gt; &#125;&gt; if (context.Statement.EndsWith(&quot;零&quot;))&gt; &#123;&gt; context.Statement = context.Statement.Substring(0, context.Statement.Length - 1);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; public abstract string GetPostFix();&gt; &gt; public abstract int Multiplier();&gt; &gt; //这个可以通用，但是对于个位数字例外，所以用虚方法&gt; public virtual int GetLength()&gt; &#123;&gt; return this.GetPostFix().Length + 1;&gt; &#125;&gt; &#125;&gt; &gt; //个位表达式&gt; public sealed class GeExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 1;&gt; &#125;&gt; &gt; public override int GetLength()&gt; &#123;&gt; return 1;&gt; &#125;&gt; &#125;&gt; &gt; //十位表达式&gt; public sealed class ShiExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;十&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 10;&gt; &#125;&gt; &#125;&gt; &gt; //百位表达式&gt; public sealed class BaiExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;百&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 100;&gt; &#125;&gt; &#125;&gt; &gt; //千位表达式&gt; public sealed class QianExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;千&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 1000;&gt; &#125;&gt; &#125;&gt; &gt; //万位表达式&gt; public sealed class WanExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;万&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 10000;&gt; &#125;&gt; &gt; public override void Interpreter(Context context)&gt; &#123;&gt; if (context.Statement.Length == 0)&gt; &#123;&gt; return;&gt; &#125;&gt; &gt; ArrayList tree = new ArrayList();&gt; &gt; tree.Add(new GeExpression());&gt; tree.Add(new ShiExpression());&gt; tree.Add(new BaiExpression());&gt; tree.Add(new QianExpression());&gt; &gt; foreach (string key in table.Keys)&gt; &#123;&gt; if (context.Statement.EndsWith(GetPostFix()))&gt; &#123;&gt; int temp = context.Data;&gt; context.Data = 0;&gt; &gt; context.Statement = context.Statement.Substring(0, context.Statement.Length - this.GetLength());&gt; &gt; foreach (Expression exp in tree)&gt; &#123;&gt; exp.Interpreter(context);&gt; &#125;&gt; context.Data = temp + context.Data * this.Multiplier();&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; //亿位表达式&gt; public sealed class YiExpression : Expression&gt; &#123;&gt; public override string GetPostFix()&gt; &#123;&gt; return &quot;亿&quot;;&gt; &#125;&gt; &gt; public override int Multiplier()&gt; &#123;&gt; return 100000000;&gt; &#125;&gt; &gt; public override void Interpreter(Context context)&gt; &#123;&gt; ArrayList tree = new ArrayList();&gt; &gt; tree.Add(new GeExpression());&gt; tree.Add(new ShiExpression());&gt; tree.Add(new BaiExpression());&gt; tree.Add(new QianExpression());&gt; &gt; foreach (string key in table.Keys)&gt; &#123;&gt; if (context.Statement.EndsWith(GetPostFix()))&gt; &#123;&gt; int temp = context.Data;&gt; context.Data = 0;&gt; context.Statement = context.Statement.Substring(0, context.Statement.Length - this.GetLength());&gt; &gt; foreach (Expression exp in tree)&gt; &#123;&gt; exp.Interpreter(context);&gt; &#125;&gt; context.Data = temp + context.Data * this.Multiplier();&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; //环境上下文&gt; public sealed class Context&gt; &#123;&gt; private string _statement;&gt; private int _data;&gt; &gt; public Context(string statement)&gt; &#123;&gt; this._statement = statement;&gt; &#125;&gt; &gt; public string Statement&gt; &#123;&gt; get &#123; return this._statement; &#125;&gt; set &#123; this._statement = value; &#125;&gt; &#125;&gt; &gt; public int Data&gt; &#123;&gt; get &#123; return this._data; &#125;&gt; set &#123; this._data = value; &#125;&gt; &#125;&gt; &#125;&gt; &gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; string roman = &quot;五亿七千三百零二万六千四百五十二&quot;;&gt; //分解：((五)亿)((七千)(三百)(零)(二)万)&gt; //((六千)(四百)(五十)(二))&gt; &gt; Context context = new Context(roman);&gt; ArrayList tree = new ArrayList();&gt; &gt; tree.Add(new GeExpression());&gt; tree.Add(new ShiExpression());&gt; tree.Add(new BaiExpression());&gt; tree.Add(new QianExpression());&gt; tree.Add(new WanExpression());&gt; tree.Add(new YiExpression());&gt; &gt; foreach (Expression exp in tree)&gt; &#123;&gt; exp.Interpreter(context);&gt; &#125;&gt; &gt; Console.Write(context.Data);&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 16.模版方法模式（Template Method）模版方法模式在一个类中形式化地定义算法，而由它的子类实现细节的处理。模版方法模式的优势是，在子类定义处理算法时不会改变算法的结构。模版方法的特点在于，每个不同的实现都需要定义一个子类，这也复合高内聚的责任分配模式，不能说成是它的缺点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&gt; // 客户端调用&gt; class Client&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 创建一个菠菜实例并调用模板方法&gt; Spinach spinach = new Spinach();&gt; spinach.CookVegetabel();&gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &gt; public abstract class Vegetabel&gt; &#123;&gt; // 模板方法，不要把模版方法定义为Virtual或abstract方法，避免被子类重写，防止更改流程的执行顺序&gt; public void CookVegetabel()&gt; &#123;&gt; Console.WriteLine(&quot;抄蔬菜的一般做法&quot;);&gt; this.pourOil();&gt; this.HeatOil();&gt; this.pourVegetable();&gt; this.stir_fry();&gt; &#125;&gt; &gt; // 第一步倒油&gt; public void pourOil()&gt; &#123;&gt; Console.WriteLine(&quot;倒油&quot;);&gt; &#125;&gt; &gt; // 把油烧热&gt; public void HeatOil()&gt; &#123;&gt; Console.WriteLine(&quot;把油烧热&quot;);&gt; &#125;&gt; &gt; // 油热了之后倒蔬菜下去，具体哪种蔬菜由子类决定&gt; public abstract void pourVegetable();&gt; &gt; // 开发翻炒蔬菜&gt; public void stir_fry()&gt; &#123;&gt; Console.WriteLine(&quot;翻炒&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 菠菜&gt; public class Spinach : Vegetabel&gt; &#123;&gt; &gt; public override void pourVegetable()&gt; &#123;&gt; Console.WriteLine(&quot;倒菠菜进锅中&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 大白菜&gt; public class ChineseCabbage : Vegetabel&gt; &#123; &gt; public override void pourVegetable()&gt; &#123;&gt; Console.WriteLine(&quot;倒大白菜进锅中&quot;);&gt; &#125;&gt; &#125;&gt; 17.迭代器模式（Iterator Pattern）迭代器模式支持在聚集中移动游标，使得访问聚合中的元素变得简单，简化了聚集的接口，封装了聚合的对象。迭代器模式还可以应用于对树结构的访问，程序不需要从头逐行代码查找相应位置，可控制到从子集开始查找，对于加快程序的运行速度有很重要的作用。迭代器模式的缺点是聚合密切相关，增加了耦合。但将这种耦合定义在抽象基类，可解决这个问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&gt; // 抽象聚合类&gt; public interface IListCollection&gt; &#123;&gt; Iterator GetIterator();&gt; &#125;&gt; &gt; // 迭代器抽象类&gt; public interface Iterator&gt; &#123;&gt; bool MoveNext();&gt; Object GetCurrent();&gt; void Next();&gt; void Reset();&gt; &#125;&gt; &gt; // 具体聚合类&gt; public class ConcreteList : IListCollection&gt; &#123;&gt; int[] collection;&gt; public ConcreteList()&gt; &#123;&gt; collection = new int[] &#123; 2, 4, 6, 8 &#125;;&gt; &#125;&gt; &gt; public Iterator GetIterator()&gt; &#123;&gt; return new ConcreteIterator(this);&gt; &#125;&gt; &gt; public int Length&gt; &#123;&gt; get &#123; return collection.Length; &#125;&gt; &#125;&gt; &gt; public int GetElement(int index)&gt; &#123;&gt; return collection[index];&gt; &#125;&gt; &#125;&gt; &gt; // 具体迭代器类&gt; public class ConcreteIterator : Iterator&gt; &#123;&gt; // 迭代器要集合对象进行遍历操作，自然就需要引用集合对象&gt; private ConcreteList _list;&gt; private int _index;&gt; &gt; public ConcreteIterator(ConcreteList list)&gt; &#123;&gt; _list = list;&gt; _index = 0;&gt; &#125;&gt; &gt; &gt; public bool MoveNext()&gt; &#123;&gt; if (_index &lt; _list.Length)&gt; &#123;&gt; return true;&gt; &#125;&gt; return false;&gt; &#125;&gt; &gt; public Object GetCurrent()&gt; &#123;&gt; return _list.GetElement(_index);&gt; &#125;&gt; &gt; public void Reset()&gt; &#123;&gt; _index = 0;&gt; &#125;&gt; &gt; public void Next()&gt; &#123;&gt; if (_index &lt; _list.Length)&gt; &#123;&gt; _index++;&gt; &#125;&gt; &gt; &#125;&gt; &#125;&gt; // 客户端&gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; Iterator iterator;&gt; IListCollection list = new ConcreteList();&gt; iterator = list.GetIterator();&gt; &gt; while (iterator.MoveNext())&gt; &#123;&gt; int i = (int)iterator.GetCurrent();&gt; Console.WriteLine(i.ToString());&gt; iterator.Next();&gt; &#125;&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; 18.观察者模式（Oberver Pattern）观察者模式抽象了被观察对象与观察者对象的连接，提供了广播式的对象间通信，并且容易增加新的观察者对象。观察者模式的缺陷是对象间的关系难以理解，在某种情况下会表现低效能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt; // 腾讯游戏订阅号类&gt; public class TenxunGame&gt; &#123;&gt; // 订阅者对象&gt; public Subscriber Subscriber &#123;get;set;&#125; &gt; &gt; public String Symbol &#123;get; set;&#125;&gt; &gt; public string Info &#123;get ;set;&#125;&gt; &gt; public void Update()&gt; &#123;&gt; if (Subscriber != null)&gt; &#123;&gt; // 调用订阅者对象来通知订阅者&gt; Subscriber.ReceiveAndPrintData(this);&gt; &#125;&gt; &#125;&gt; &gt; &#125;&gt; // 订阅者类&gt; public class Subscriber&gt; &#123;&gt; public string Name &#123; get; set; &#125;&gt; public Subscriber(string name)&gt; &#123;&gt; this.Name = name;&gt; &#125;&gt; &gt; public void ReceiveAndPrintData(TenxunGame txGame)&gt; &#123;&gt; Console.WriteLine(&quot;Notified &#123;0&#125; of &#123;1&#125;&apos;s&quot; + &quot; Info is: &#123;2&#125;&quot;, Name, txGame.Symbol, txGame.Info);&gt; &#125;&gt; &#125;&gt; // 客户端测试&gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 实例化订阅者和订阅号对象&gt; Subscriber LearningHardSub = new Subscriber(&quot;LearningHard&quot;);&gt; TenxunGame txGame = new TenxunGame();&gt; &gt; txGame.Subscriber = LearningHardSub;&gt; txGame.Symbol = &quot;TenXun Game&quot;;&gt; txGame.Info = &quot;Have a new game published ....&quot;;&gt; &gt; txGame.Update();&gt; &gt; Console.ReadLine();&gt; &#125;&gt; &#125;&gt; 19.中介者模式（Mediator Pattern）中介者模式分离了两个同事类，简化了对象协议，中央控制对象交互，从而使个体对象变得更容易且更简单，因为它不需要传递数据给其他个体对象，仅仅传给中介者就可以了。个体对象不需要具有处理内部交流的逻辑，所以更加突出它的面向对象特性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&gt; // 抽象牌友类&gt; public abstract class AbstractCardPartner&gt; &#123;&gt; public int MoneyCount &#123; get; set; &#125;&gt; &gt; public AbstractCardPartner()&gt; &#123;&gt; MoneyCount = 0;&gt; &#125;&gt; &gt; public abstract void ChangeCount(int Count, AbstractCardPartner other);&gt; &#125;&gt; &gt; // 牌友A类&gt; public class ParterA : AbstractCardPartner&gt; &#123;&gt; public override void ChangeCount(int Count, AbstractCardPartner other)&gt; &#123;&gt; this.MoneyCount += Count;&gt; other.MoneyCount -= Count;&gt; &#125;&gt; &#125;&gt; &gt; // 牌友B类&gt; public class ParterB : AbstractCardPartner&gt; &#123;&gt; public override void ChangeCount(int Count, AbstractCardPartner other)&gt; &#123;&gt; this.MoneyCount += Count;&gt; other.MoneyCount -= Count;&gt; &#125;&gt; &#125;&gt; &gt; class Program&gt; &#123;&gt; // A,B两个人打牌&gt; static void Main(string[] args)&gt; &#123;&gt; AbstractCardPartner A = new ParterA();&gt; A.MoneyCount = 20;&gt; AbstractCardPartner B = new ParterB();&gt; B.MoneyCount = 20;&gt; &gt; // A 赢了则B的钱就减少&gt; A.ChangeCount(5, B);&gt; Console.WriteLine(&quot;A 现在的钱是：&#123;0&#125;&quot;, A.MoneyCount);// 应该是25&gt; Console.WriteLine(&quot;B 现在的钱是：&#123;0&#125;&quot;, B.MoneyCount); // 应该是15&gt; &gt; // B赢了A的钱也减少&gt; B.ChangeCount(10, A);&gt; Console.WriteLine(&quot;A 现在的钱是：&#123;0&#125;&quot;, A.MoneyCount); // 应该是15&gt; Console.WriteLine(&quot;B 现在的钱是：&#123;0&#125;&quot;, B.MoneyCount); // 应该是25&gt; Console.Read(); &gt; &#125;&gt; &#125;&gt; 20.备忘录模式（Memento Pattern）Memento模式保存了封装的边界，一个Memento对象是另一种原发器对象的表示，不会被其他代码改动。这种模式简化了原发器对象，Memento只保存原发器的状态。采用堆栈备忘对象，可以实现多次取消操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&gt; // 联系人&gt; public class ContactPerson&gt; &#123;&gt; public string Name &#123; get; set; &#125;&gt; public string MobileNum &#123; get; set; &#125;&gt; &#125;&gt; &gt; // 发起人&gt; public class MobileOwner&gt; &#123;&gt; // 发起人需要保存的内部状态&gt; public List&lt;ContactPerson&gt; ContactPersons &#123; get; set; &#125;&gt; &gt; public MobileOwner(List&lt;ContactPerson&gt; persons)&gt; &#123;&gt; ContactPersons = persons;&gt; &#125;&gt; &gt; // 创建备忘录，将当期要保存的联系人列表导入到备忘录中 &gt; public ContactMemento CreateMemento()&gt; &#123;&gt; // 这里也应该传递深拷贝，new List方式传递的是浅拷贝，&gt; // 因为ContactPerson类中都是string类型,所以这里new list方式对ContactPerson对象执行了深拷贝&gt; // 如果ContactPerson包括非string的引用类型就会有问题，所以这里也应该用序列化传递深拷贝&gt; return new ContactMemento(new List&lt;ContactPerson&gt;(this.ContactPersons));&gt; &#125;&gt; &gt; // 将备忘录中的数据备份导入到联系人列表中&gt; public void RestoreMemento(ContactMemento memento)&gt; &#123;&gt; // 下面这种方式是错误的，因为这样传递的是引用，&gt; // 则删除一次可以恢复，但恢复之后再删除的话就恢复不了.&gt; // 所以应该传递contactPersonBack的深拷贝，深拷贝可以使用序列化来完成&gt; this.ContactPersons = memento.contactPersonBack;&gt; &#125;&gt; &gt; public void Show()&gt; &#123;&gt; Console.WriteLine(&quot;联系人列表中有&#123;0&#125;个人，他们是:&quot;, ContactPersons.Count);&gt; foreach (ContactPerson p in ContactPersons)&gt; &#123;&gt; Console.WriteLine(&quot;姓名: &#123;0&#125; 号码为: &#123;1&#125;&quot;, p.Name, p.MobileNum);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; // 备忘录&gt; public class ContactMemento&gt; &#123;&gt; // 保存发起人的内部状态&gt; public List&lt;ContactPerson&gt; contactPersonBack;&gt; &gt; public ContactMemento(List&lt;ContactPerson&gt; persons)&gt; &#123;&gt; contactPersonBack = persons;&gt; &#125;&gt; &#125;&gt; &gt; // 管理角色&gt; public class Caretaker&gt; &#123;&gt; public ContactMemento ContactM &#123; get; set; &#125;&gt; &#125;&gt; &gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; List&lt;ContactPerson&gt; persons = new List&lt;ContactPerson&gt;()&gt; &#123;&gt; new ContactPerson() &#123; Name= &quot;Learning Hard&quot;, MobileNum = &quot;123445&quot;&#125;,&gt; new ContactPerson() &#123; Name = &quot;Tony&quot;, MobileNum = &quot;234565&quot;&#125;,&gt; new ContactPerson() &#123; Name = &quot;Jock&quot;, MobileNum = &quot;231455&quot;&#125;&gt; &#125;;&gt; MobileOwner mobileOwner = new MobileOwner(persons);&gt; mobileOwner.Show();&gt; &gt; // 创建备忘录并保存备忘录对象&gt; Caretaker caretaker = new Caretaker();&gt; caretaker.ContactM = mobileOwner.CreateMemento();&gt; &gt; // 更改发起人联系人列表&gt; Console.WriteLine(&quot;----移除最后一个联系人--------&quot;);&gt; mobileOwner.ContactPersons.RemoveAt(2);&gt; mobileOwner.Show();&gt; &gt; // 恢复到原始状态&gt; Console.WriteLine(&quot;-------恢复联系人列表------&quot;);&gt; mobileOwner.RestoreMemento(caretaker.ContactM);&gt; mobileOwner.Show();&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; 21.状态模式（State Pattern）状态模式在对象内保存特定的状态并且就不同的状态履行不同的行为，它使状态的变化显得清晰明了，也很容易创建对象的新状态。状态模式在工作流或游戏等各种系统中大量使用，例如在政府OA系统中，一个批文的状态有多种：未办、正在处理、正在批示、正在审核和已经完成等各种状态。在网络游戏中，一个游戏活动存在开始、开玩、正在玩、输赢等各种状态。使用状态模式就可以实现游戏状态的总控，而游戏状态决定了游戏的各个方面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213&gt; namespace StatePatternSample&gt; &#123;&gt; public class Account&gt; &#123;&gt; public State State &#123;get;set;&#125;&gt; public string Owner &#123; get; set; &#125;&gt; public Account(string owner)&gt; &#123;&gt; this.Owner = owner;&gt; this.State = new SilverState(0.0, this);&gt; &#125;&gt; &gt; public double Balance &#123; get &#123;return State.Balance; &#125;&#125; // 余额&gt; // 存钱&gt; public void Deposit(double amount)&gt; &#123;&gt; State.Deposit(amount);&gt; Console.WriteLine(&quot;存款金额为 &#123;0:C&#125;——&quot;, amount);&gt; Console.WriteLine(&quot;账户余额为 =:&#123;0:C&#125;&quot;, this.Balance);&gt; Console.WriteLine(&quot;账户状态为: &#123;0&#125;&quot;, this.State.GetType().Name);&gt; Console.WriteLine();&gt; &#125;&gt; &gt; // 取钱&gt; public void Withdraw(double amount)&gt; &#123;&gt; State.Withdraw(amount);&gt; Console.WriteLine(&quot;取款金额为 &#123;0:C&#125;——&quot;,amount);&gt; Console.WriteLine(&quot;账户余额为 =:&#123;0:C&#125;&quot;, this.Balance);&gt; Console.WriteLine(&quot;账户状态为: &#123;0&#125;&quot;, this.State.GetType().Name);&gt; Console.WriteLine();&gt; &#125;&gt; &gt; // 获得利息&gt; public void PayInterest()&gt; &#123;&gt; State.PayInterest();&gt; Console.WriteLine(&quot;Interest Paid --- &quot;);&gt; Console.WriteLine(&quot;账户余额为 =:&#123;0:C&#125;&quot;, this.Balance);&gt; Console.WriteLine(&quot;账户状态为: &#123;0&#125;&quot;, this.State.GetType().Name);&gt; Console.WriteLine();&gt; &#125;&gt; &#125;&gt; &gt; // 抽象状态类&gt; public abstract class State&gt; &#123;&gt; // Properties&gt; public Account Account &#123; get; set; &#125;&gt; public double Balance &#123; get; set; &#125; // 余额&gt; public double Interest &#123; get; set; &#125; // 利率&gt; public double LowerLimit &#123; get; set; &#125; // 下限&gt; public double UpperLimit &#123; get; set; &#125; // 上限&gt; &gt; public abstract void Deposit(double amount); // 存款&gt; public abstract void Withdraw(double amount); // 取钱&gt; public abstract void PayInterest(); // 获得的利息&gt; &#125;&gt; &gt; // Red State意味着Account透支了&gt; public class RedState : State&gt; &#123;&gt; public RedState(State state)&gt; &#123;&gt; // Initialize&gt; this.Balance = state.Balance;&gt; this.Account = state.Account;&gt; Interest = 0.00;&gt; LowerLimit = -100.00;&gt; UpperLimit = 0.00;&gt; &#125;&gt; &gt; // 存款&gt; public override void Deposit(double amount)&gt; &#123;&gt; Balance += amount;&gt; StateChangeCheck();&gt; &#125;&gt; // 取钱&gt; public override void Withdraw(double amount)&gt; &#123;&gt; Console.WriteLine(&quot;没有钱可以取了！&quot;);&gt; &#125;&gt; &gt; public override void PayInterest()&gt; &#123;&gt; // 没有利息&gt; &#125;&gt; &gt; private void StateChangeCheck()&gt; &#123;&gt; if (Balance &gt; UpperLimit)&gt; &#123;&gt; Account.State = new SilverState(this);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; // Silver State意味着没有利息得&gt; public class SilverState :State&gt; &#123;&gt; public SilverState(State state)&gt; : this(state.Balance, state.Account)&gt; &#123; &gt; &#125;&gt; &gt; public SilverState(double balance, Account account)&gt; &#123;&gt; this.Balance = balance;&gt; this.Account = account;&gt; Interest = 0.00;&gt; LowerLimit = 0.00;&gt; UpperLimit = 1000.00;&gt; &#125;&gt; &gt; public override void Deposit(double amount)&gt; &#123;&gt; Balance += amount;&gt; StateChangeCheck();&gt; &#125;&gt; public override void Withdraw(double amount)&gt; &#123;&gt; Balance -= amount;&gt; StateChangeCheck();&gt; &#125;&gt; &gt; public override void PayInterest()&gt; &#123;&gt; Balance += Interest * Balance;&gt; StateChangeCheck();&gt; &#125;&gt; &gt; private void StateChangeCheck()&gt; &#123;&gt; if (Balance &lt; LowerLimit)&gt; &#123;&gt; Account.State = new RedState(this);&gt; &#125;&gt; else if (Balance &gt; UpperLimit)&gt; &#123;&gt; Account.State = new GoldState(this);&gt; &#125;&gt; &#125; &gt; &#125;&gt; &gt; // Gold State意味着有利息状态&gt; public class GoldState : State&gt; &#123;&gt; public GoldState(State state)&gt; &#123;&gt; this.Balance = state.Balance;&gt; this.Account = state.Account;&gt; Interest = 0.05;&gt; LowerLimit = 1000.00;&gt; UpperLimit = 1000000.00;&gt; &#125;&gt; // 存钱&gt; public override void Deposit(double amount)&gt; &#123;&gt; Balance += amount;&gt; StateChangeCheck();&gt; &#125;&gt; // 取钱&gt; public override void Withdraw(double amount)&gt; &#123;&gt; Balance -= amount;&gt; StateChangeCheck();&gt; &#125;&gt; public override void PayInterest()&gt; &#123;&gt; Balance += Interest * Balance;&gt; StateChangeCheck();&gt; &#125;&gt; &gt; private void StateChangeCheck()&gt; &#123;&gt; if (Balance &lt; 0.0)&gt; &#123;&gt; Account.State = new RedState(this);&gt; &#125;&gt; else if (Balance &lt; LowerLimit)&gt; &#123;&gt; Account.State = new SilverState(this);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; class App&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 开一个新的账户&gt; Account account = new Account(&quot;Learning Hard&quot;);&gt; &gt; // 进行交易&gt; // 存钱&gt; account.Deposit(1000.0);&gt; account.Deposit(200.0);&gt; account.Deposit(600.0);&gt; &gt; // 付利息&gt; account.PayInterest();&gt; &gt; // 取钱&gt; account.Withdraw(2000.00);&gt; account.Withdraw(500.00);&gt; &gt; // 等待用户输入&gt; Console.ReadKey();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 22.策略模式（Strategy Pattern）策略模式提供了替代派生的子类，并定义类的每个行为，剔除了代码中条件的判断语句，使得扩展和结合新的行为变得更容易，根本不需要变动应用程序。策略模式可以避免使用多重条件转移语句，系统变得更新灵活。应用策略模式会产生很多子类，这符合高内聚的责任分配模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&gt; namespace StrategyPattern&gt; &#123;&gt; // 所得税计算策略&gt; public interface ITaxStragety&gt; &#123;&gt; double CalculateTax(double income);&gt; &#125;&gt; &gt; // 个人所得税&gt; public class PersonalTaxStrategy : ITaxStragety&gt; &#123;&gt; public double CalculateTax(double income)&gt; &#123;&gt; return income * 0.12;&gt; &#125;&gt; &#125;&gt; &gt; // 企业所得税&gt; public class EnterpriseTaxStrategy : ITaxStragety&gt; &#123;&gt; public double CalculateTax(double income)&gt; &#123;&gt; return (income - 3500) &gt; 0 ? (income - 3500) * 0.045 : 0.0;&gt; &#125;&gt; &#125;&gt; &gt; public class InterestOperation&gt; &#123;&gt; private ITaxStragety m_strategy;&gt; public InterestOperation(ITaxStragety strategy)&gt; &#123;&gt; this.m_strategy = strategy;&gt; &#125;&gt; &gt; public double GetTax(double income)&gt; &#123;&gt; return m_strategy.CalculateTax(income);&gt; &#125;&gt; &#125;&gt; &gt; class App&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; // 个人所得税方式&gt; InterestOperation operation = new InterestOperation(new PersonalTaxStrategy());&gt; Console.WriteLine(&quot;个人支付的税为：&#123;0&#125;&quot;, operation.GetTax(5000.00));&gt; &gt; // 企业所得税&gt; operation = new InterestOperation(new EnterpriseTaxStrategy());&gt; Console.WriteLine(&quot;企业支付的税为：&#123;0&#125;&quot;, operation.GetTax(50000.00));&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &#125;&gt; 23.访问者模式（Visitor Pattern）Visitor(访问者)模式使得增加新的操作变得容易，它可以收集有关联的方法，而分离没有关联的方法，特别适用于分离因为不同原因而变化的事物，如“在男人中分离出男孩”。但Visitor模式常常要打破对象的封装性，visitor与element需要达成某些共识。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&gt; namespace DonotUsevistorPattern&gt; &#123;&gt; // 抽象元素角色&gt; public abstract class Element&gt; &#123; &gt; public abstract void Print();&gt; &#125;&gt; &gt; // 具体元素A&gt; public class ElementA : Element&gt; &#123; &gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;我是元素A&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 具体元素B&gt; public class ElementB : Element&gt; &#123;&gt; public override void Print()&gt; &#123;&gt; Console.WriteLine(&quot;我是元素B&quot;);&gt; &#125;&gt; &#125;&gt; &gt; // 对象结构&gt; public class ObjectStructure&gt; &#123;&gt; private ArrayList elements = new ArrayList();&gt; &gt; public ArrayList Elements&gt; &#123;&gt; get &#123; return elements; &#125;&gt; &#125;&gt; &gt; public ObjectStructure()&gt; &#123;&gt; Random ran = new Random();&gt; for (int i = 0; i &lt; 6; i++)&gt; &#123;&gt; int ranNum = ran.Next(10);&gt; if (ranNum &gt; 5)&gt; &#123;&gt; elements.Add(new ElementA());&gt; &#125;&gt; else&gt; &#123;&gt; elements.Add(new ElementB());&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; class Program&gt; &#123;&gt; static void Main(string[] args)&gt; &#123;&gt; ObjectStructure objectStructure = new ObjectStructure();&gt; // 遍历对象结构中的对象集合，访问每个元素的Print方法打印元素信息&gt; foreach (Element e in objectStructure.Elements)&gt; &#123;&gt; e.Print();&gt; &#125;&gt; &gt; Console.Read();&gt; &#125;&gt; &#125;&gt; &#125;&gt;","tags":[{"name":".net","slug":"net","permalink":"https://github-lu.github.io/tags/net/"}]},{"title":"基于Microsoft Exchange Server发送邮件","date":"2018-06-28T12:39:34.000Z","path":"2018/06/28/基于Microsoft Exchange Server发送邮件/","text":"由于项目需要需要一个邮件功能，需要将数据库里数据导出Excel并且自动发送邮件的功能，我就在网上查资料。基于SMTP与POP3协议的发送邮件网上代码很多，自己配置了一下可以实现。但是后来为了安全考虑（其实是公司有微软域邮箱），需要采用微软的Exchange Server发送邮件。。。。 首先我们需要安装一个Microsoft.Exchange.WebServices的Nuget包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt;/// 邮件发送服务/// &lt;/summary&gt;public class MailService&#123; /// &lt;summary&gt; /// /// &lt;/summary&gt; public static readonly MailService Instance = new MailService(); #region 邮件发送 /// &lt;summary&gt; /// 邮件服务配置 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public static ExchangeService _ExchangeService() &#123; ExchangeService service = new ExchangeService(ExchangeVersion.Exchange2007_SP1); string user = ConfigurationManager.AppSettings[&quot;User&quot;]; string password = ConfigurationManager.AppSettings[&quot;password&quot;]; string domain = ConfigurationManager.AppSettings[&quot;Domain&quot;]; service.Credentials = new NetworkCredential(user, password, domain); service.TraceEnabled = true; ServicePointManager.ServerCertificateValidationCallback += CheckCert; service.AutodiscoverUrl(user+&quot;@sinooceangroup.com&quot;); return service; &#125; /// &lt;summary&gt; /// 检验证书始终返回true /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;certificate&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;chain&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;sslPolicyErrors&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; protected static bool CheckCert(Object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) &#123; return true; &#125; /// &lt;summary&gt; /// 封装EmailMessage保存封装方法 /// &lt;/summary&gt; /// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt; public void SendEmail(EmailMessage message) &#123; message.Save(); message.SendAndSaveCopy();// 发送 &#125; #endregion 上面是核心代码，接下来是如何调用 12345678910111213141516171819public IHttpActionResult SendMailTest(string email) &#123; var result = ControllerService.Run(() =&gt; &#123; var service = MailService._ExchangeService(); Microsoft.Exchange.WebServices.Data.EmailMessage message = new Microsoft.Exchange.WebServices.Data.EmailMessage(service); message.Subject = &quot;测试标题&quot;; message.Body = new Microsoft.Exchange.WebServices.Data.MessageBody(); message.Body.BodyType = Microsoft.Exchange.WebServices.Data.BodyType.HTML; var stream = File.OpenRead(HttpRuntime.AppDomainAppPath + &quot;/HtmlTemplate/mail.html&quot;); StreamReader sr = new StreamReader(stream); string str = sr.ReadToEnd();//字符串 message.Body.Text = str; message.ToRecipients.Add(email); MailService.Instance.SendEmail(message); &#125;); return Ok(result); &#125;","tags":[{"name":"邮件","slug":"邮件","permalink":"https://github-lu.github.io/tags/邮件/"}]},{"title":"SMTP协议发送邮件","date":"2018-06-25T08:39:34.000Z","path":"2018/06/25/SMTP发送邮件/","text":"例如A使用163邮箱发送邮件给B(qq邮箱)。首先A会把邮件通过SMTP（Simple Mail Transfer Protocol）协议传输到163的Smtp服务器上，163的Smtp服务器会根据B的邮箱账号，把邮件通过Smtp协议发给QQ邮箱的Smtp服务器。QQ的Smtp服务器接收到邮件消息后会将之存储在QQ邮箱的邮件存储设备上。当B登陆QQ邮箱后，如果有新邮件，POP3服务器就会从QQ邮箱的邮件存储设备上读出邮件并通过POP3/IMAP服务发送给邮件客户端的B。12345678910111213141516171819202122232425262728293031323334353637private void SendMail() &#123; //简单邮件传输协议类 System.Net.Mail.SmtpClient client = new System.Net.Mail.SmtpClient(); client.Host = &quot;smtp.ym.163.com&quot;;//邮件服务器 client.Port = 25;//smtp主机上的端口号,默认是25. client.DeliveryMethod = System.Net.Mail.SmtpDeliveryMethod.Network;//邮件发送方式:通过网络发送到SMTP服务器 client.Credentials = new System.Net.NetworkCredential(&quot;登录人邮箱&quot;, &quot;邮箱密码&quot;);//凭证,发件人登录邮箱的用户名和密码 //电子邮件信息类 System.Net.Mail.MailAddress fromAddress = new System.Net.Mail.MailAddress(&quot;发送人邮箱&quot;, &quot;名称&quot;);//发件人Email,在邮箱是这样显示的,[发件人:小明&lt;panthervic@163.com&gt;;] System.Net.Mail.MailAddress toAddress = new System.Net.Mail.MailAddress(&quot;收件人邮箱&quot;, &quot;名称&quot;);//收件人Email,在邮箱是这样显示的, [收件人:小红&lt;43327681@163.com&gt;;] System.Net.Mail.MailMessage mailMessage = new System.Net.Mail.MailMessage(fromAddress, toAddress);//创建一个电子邮件类 mailMessage.Subject = &quot;TaskService停止&quot;; //string filePath = Server.MapPath(&quot;/index.html&quot;);//邮件的内容可以是一个html文本. //System.IO.StreamReader read = new System.IO.StreamReader(filePath, System.Text.Encoding.GetEncoding(&quot;GB2312&quot;)); //string mailBody = read.ReadToEnd(); //read.Close(); //mailMessage.Body = mailBody;//可为html格式文本 IPHostEntry fromHE = Dns.GetHostEntry(Dns.GetHostName()); IPEndPoint ipEndPointFrom = new IPEndPoint(fromHE.AddressList[1], 80); EndPoint EndPointFrom = (ipEndPointFrom); mailMessage.Body = &quot;服务器地址：&quot;+ EndPointFrom;//可为html格式文本 mailMessage.SubjectEncoding = System.Text.Encoding.UTF8;//邮件主题编码 mailMessage.BodyEncoding = System.Text.Encoding.UTF8;//邮件内容编码 mailMessage.IsBodyHtml = true;//邮件内容是否为html格式 mailMessage.Priority = System.Net.Mail.MailPriority.High;//邮件的优先级,有三个值:高(在邮件主题前有一个红色感叹号,表示紧急),低(在邮件主题前有一个蓝色向下箭头,表示缓慢),正常(无显示). try &#123; client.Send(mailMessage);//发送邮件 //client.SendAsync(mailMessage, &quot;ojb&quot;);异步方法发送邮件,不会阻塞线程. &#125; catch (Exception ex) &#123; Console.WriteLine(ex); &#125; &#125;","tags":[{"name":"邮件","slug":"邮件","permalink":"https://github-lu.github.io/tags/邮件/"}]},{"title":"SqlDbHelper","date":"2018-05-12T12:39:34.000Z","path":"2018/05/12/SqlDbHelper/","text":"asp.net 项目基本上都是有数据库服务支持的，这就需要有一个比较常用的类支持文件。 闲话不多说，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376 /// &lt;summary&gt; /// 针对SQL Server数据库操作的通用类 /// &lt;/summary&gt; public class SqlDbHelper &#123; private string connectionString; /// &lt;summary&gt; /// 设置数据库连接字符串 /// &lt;/summary&gt; public string ConnectionString &#123; set &#123; connectionString = value; &#125; &#125; /// &lt;summary&gt; /// 构造函数（默认连接：xxxx） /// &lt;/summary&gt; public SqlDbHelper() : this(ConfigurationManager.ConnectionStrings[&quot;xxxx&quot;].ConnectionString) &#123; &#125; /// &lt;summary&gt; /// 构造函数（需要传入新的连接字符串） /// &lt;/summary&gt; /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt; public SqlDbHelper(string connectionString) &#123; this.connectionString = connectionString; &#125; #region 执行一个查询，并返回 DataTable /// &lt;summary&gt; /// 执行一个查询，并返回 DataTable /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的查询SQL文本命令&lt;/param&gt; public DataTable ExecuteDataTable(string sql) &#123; return ExecuteDataTable(sql, CommandType.Text, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回 DataTable /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; public DataTable ExecuteDataTable(string sql, CommandType commandType) &#123; return ExecuteDataTable(sql, commandType, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回 DataTable /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;param name=&quot;parameters&quot;&gt;Transact-SQL 语句或存储过程的参数数组&lt;/param&gt; public DataTable ExecuteDataTable(string sql, CommandType commandType, SqlParameter[] parameters) &#123; DataTable data = new DataTable();//实例化DataTable，用于装载查询结果集 using (SqlConnection connection = new SqlConnection(connectionString)) &#123; using (SqlCommand command = new SqlCommand(sql, connection)) &#123; command.CommandType = commandType;//设置command的CommandType为指定的CommandType //如果同时传入了参数，则添加这些参数 if (parameters != null) &#123; foreach (SqlParameter parameter in parameters) &#123; command.Parameters.Add(parameter); &#125; &#125; //通过包含查询SQL的SqlCommand实例来实例化SqlDataAdapter SqlDataAdapter adapter = new SqlDataAdapter(command); adapter.Fill(data); &#125; &#125; return data; &#125; #endregion #region 执行一个查询，并返回 SqlDataReader /// &lt;summary&gt; /// 执行一个查询，并返回 SqlDataReader /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的查询SQL文本命令&lt;/param&gt; public SqlDataReader ExecuteReader(string sql) &#123; return ExecuteReader(sql, CommandType.Text, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回 SqlDataReader /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; public SqlDataReader ExecuteReader(string sql, CommandType commandType) &#123; return ExecuteReader(sql, commandType, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回 SqlDataReader /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;param name=&quot;parameters&quot;&gt;Transact-SQL 语句或存储过程的参数数组&lt;/param&gt; public SqlDataReader ExecuteReader(string sql, CommandType commandType, SqlParameter[] parameters) &#123; SqlConnection connection = new SqlConnection(connectionString); SqlCommand command = new SqlCommand(sql, connection); //如果同时传入了参数，则添加这些参数 if (parameters != null) &#123; foreach (SqlParameter parameter in parameters) &#123; command.Parameters.Add(parameter); &#125; &#125; connection.Open(); //CommandBehavior.CloseConnection参数指示关闭Reader对象时关闭与其关联的Connection对象 return command.ExecuteReader(CommandBehavior.CloseConnection); &#125; #endregion #region 执行一个查询，并返回一行一列的 Object /// &lt;summary&gt; /// 执行一个查询，并返回一行一列的 Object /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的查询SQL文本命令&lt;/param&gt; public Object ExecuteScalar(string sql) &#123; return ExecuteScalar(sql, CommandType.Text, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回一行一列的 Object /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; public Object ExecuteScalar(string sql, CommandType commandType) &#123; return ExecuteScalar(sql, commandType, null); &#125; /// &lt;summary&gt; /// 执行一个查询，并返回一行一列的 Object /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;param name=&quot;parameters&quot;&gt;Transact-SQL 语句或存储过程的参数数组&lt;/param&gt; public Object ExecuteScalar(string sql, CommandType commandType, SqlParameter[] parameters) &#123; object result = null; using (SqlConnection connection = new SqlConnection(connectionString)) &#123; using (SqlCommand command = new SqlCommand(sql, connection)) &#123; command.CommandType = commandType;//设置command的CommandType为指定的CommandType //如果同时传入了参数，则添加这些参数 if (parameters != null) &#123; foreach (SqlParameter parameter in parameters) &#123; command.Parameters.Add(parameter); &#125; &#125; connection.Open();//打开数据库连接 result = command.ExecuteScalar(); &#125; &#125; return result;//返回查询结果的第一行第一列，忽略其它行和列 &#125; #endregion #region 对数据库执行增删改操作 /// &lt;summary&gt; /// 对数据库执行增删改操作 /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的查询SQL文本命令&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public int ExecuteNonQuery(string sql) &#123; return ExecuteNonQuery(sql, CommandType.Text, null); &#125; /// &lt;summary&gt; /// 对数据库执行增删改操作 /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; public int ExecuteNonQuery(string sql, CommandType commandType) &#123; return ExecuteNonQuery(sql, commandType, null); &#125; /// &lt;summary&gt; /// 对数据库执行增删改操作 /// &lt;/summary&gt; /// &lt;param name=&quot;sql&quot;&gt;要执行的SQL语句&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;param name=&quot;parameters&quot;&gt;Transact-SQL 语句或存储过程的参数数组&lt;/param&gt; public int ExecuteNonQuery(string sql, CommandType commandType, SqlParameter[] parameters) &#123; int count = 0; using (SqlConnection connection = new SqlConnection(connectionString)) &#123; using (SqlCommand command = new SqlCommand(sql, connection)) &#123; command.CommandType = commandType;//设置command的CommandType为指定的CommandType //如果同时传入了参数，则添加这些参数 if (parameters != null) &#123; foreach (SqlParameter parameter in parameters) &#123; command.Parameters.Add(parameter); &#125; &#125; connection.Open();//打开数据库连接 count = command.ExecuteNonQuery(); &#125; &#125; return count;//返回执行增删改操作之后，数据库中受影响的行数 &#125; #endregion #region 以事务的模式对数据库执行增删改操作 /// &lt;summary&gt; /// 以事务的模式对数据库执行增删改操作 /// &lt;/summary&gt; /// &lt;param name=&quot;sqlArray&quot;&gt;要执行的SQL语句数组&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;param name=&quot;parametersArray&quot;&gt;Transact-SQL 语句或存储过程的参数数组&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool ExecuteNonQueryTransation(List&lt;string&gt; sqlArray, CommandType commandType, List&lt;SqlParameter[]&gt; parametersArray) &#123; bool result = false; using (SqlConnection connection = new SqlConnection(connectionString)) &#123; connection.Open();//打开数据库连接 //事务处理 using (SqlTransaction transaction = connection.BeginTransaction()) &#123; try &#123; for (int i = 0; i &lt; sqlArray.Count; i++) &#123; string sqlString = sqlArray[i]; using (SqlCommand command = new SqlCommand(sqlString, connection, transaction)) &#123; command.CommandType = commandType;//设置command的CommandType为指定的CommandType //如果同时传入了参数，则添加这些参数 if (parametersArray!=null) &#123; if (parametersArray[i] != null) &#123; foreach (SqlParameter parameter in parametersArray[i]) &#123; if (parameter.SqlValue == null) &#123; parameter.SqlValue = DBNull.Value; &#125; command.Parameters.Add(parameter); &#125; &#125; &#125; command.ExecuteNonQuery(); &#125; &#125; transaction.Commit(); //事务提交 result = true; &#125; catch (Exception ex) &#123; transaction.Rollback(); //事务回滚 return false; &#125; &#125; &#125; return result;//返回执行增删改操作之后，数据库中受影响的行数 &#125; /// &lt;summary&gt; /// 以事务的模式对数据库执行增删改操作 /// &lt;/summary&gt; /// &lt;param name=&quot;sqlArray&quot;&gt;要执行的SQL语句数组&lt;/param&gt; /// &lt;param name=&quot;commandType&quot;&gt;要执行的查询语句的类型，如存储过程或者SQL文本命令&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public bool ExecuteNonQueryTransation(List&lt;string&gt; sqlArray, CommandType commandType) &#123; bool result = false; using (SqlConnection connection = new SqlConnection(connectionString)) &#123; connection.Open();//打开数据库连接 //事务处理 using (SqlTransaction transaction = connection.BeginTransaction()) &#123; try &#123; for (int i = 0; i &lt; sqlArray.Count; i++) &#123; string sqlString = sqlArray[i]; using (SqlCommand command = new SqlCommand(sqlString, connection, transaction)) &#123; command.CommandType = commandType;//设置command的CommandType为指定的CommandType command.ExecuteNonQuery(); &#125; &#125; transaction.Commit(); //事务提交 result = true; &#125; catch (Exception ex) &#123; transaction.Rollback(); //事务回滚 return false; &#125; &#125; &#125; return result;//返回执行增删改操作之后，数据库中受影响的行数 &#125; #endregion #region 批量插入数据 public static void BulkInsertData(DataTable dt, string tableName, string connName) &#123; var connStr = DbConnectionManager.GetConnectionString(connName); SqlConnection conn = new SqlConnection(connStr); conn.Open(); SqlTransaction tran = conn.BeginTransaction(); SqlBulkCopy sqlBulkCopy = new SqlBulkCopy(conn, SqlBulkCopyOptions.KeepIdentity, tran);//创建SqlBulkCopy对象 // bulkCopy = new SqlBulkCopy(sqlConn, SqlBulkCopyOptions.KeepNulls, tran); try &#123; sqlBulkCopy.DestinationTableName = tableName;//目标数据库表名 sqlBulkCopy.BatchSize = 1000;//一次批量执行的数据量 sqlBulkCopy.ColumnMappings.Clear(); for (int j = 0; j &lt; dt.Columns.Count; j++) &#123; sqlBulkCopy.ColumnMappings.Add((string)dt.Columns[j].ColumnName, (string)dt.Columns[j].ColumnName);//添加要保存的列 &#125; sqlBulkCopy.WriteToServer(dt);//将源表中的数据写入数据库中目标表中 tran.Commit(); &#125; catch (Exception) &#123; tran.Rollback(); throw; &#125; finally &#123; sqlBulkCopy.Close(); conn.Close(); //GC.Collect(); &#125; &#125; #endregion&#125; 上面是核心代码，接下来是如何调用 12345678910111213141516171819public IHttpActionResult SendMailTest(string email) &#123; var result = ControllerService.Run(() =&gt; &#123; var service = MailService._ExchangeService(); Microsoft.Exchange.WebServices.Data.EmailMessage message = new Microsoft.Exchange.WebServices.Data.EmailMessage(service); message.Subject = &quot;测试标题&quot;; message.Body = new Microsoft.Exchange.WebServices.Data.MessageBody(); message.Body.BodyType = Microsoft.Exchange.WebServices.Data.BodyType.HTML; var stream = File.OpenRead(HttpRuntime.AppDomainAppPath + &quot;/HtmlTemplate/mail.html&quot;); StreamReader sr = new StreamReader(stream); string str = sr.ReadToEnd();//字符串 message.Body.Text = str; message.ToRecipients.Add(email); MailService.Instance.SendEmail(message); &#125;); return Ok(result); &#125;","tags":[{"name":"数据库","slug":"数据库","permalink":"https://github-lu.github.io/tags/数据库/"}]},{"title":"Redis缓存技术（下）","date":"2018-04-04T10:34:34.000Z","path":"2018/04/04/Redis缓存技术（下）/","text":"继上一篇的Redis安装篇后，今天我们来研究以下C#具体操作Redis的方法 代码篇首先我们安装依赖库 代码如下： 12345678910111213141516static void Main(string[] args) &#123; var redis = ConnectionMultiplexer.Connect(&quot;Localhost:6479,password=ztredis(*)134&amp;^%xswed&quot;); var rel = &quot;&quot;; //redis.GetDatabase(0)指定数据库0； //如果不填写则默认为-1 IDatabase db = redis.GetDatabase(0); db.StringSet(&quot;key&quot;, &quot;Hello World&quot;);//把值存入key中 rel = db.StringGet(&quot;key&quot;);//读取key中的值 Console.Write(rel);//打印key中的值 DateTime time = DateTime.Now.AddDays(30); db.KeyExpire(&quot;key&quot;, time);//设置key失效时间 redis.Close();//关闭连接 redis.Dispose();//释放资源 Console.Read(); &#125; 控制台结果如下: Redis客户端如下： 以上就是我们C#写入读取Reids的简单示例","tags":[{"name":"缓存","slug":"缓存","permalink":"https://github-lu.github.io/tags/缓存/"}]},{"title":"Redis缓存技术（上）","date":"2018-04-04T03:20:11.000Z","path":"2018/04/04/Redis缓存技术（上）/","text":"今天做的笔记是Redis缓存技术，主要是安装 详细内容参考：https://blog.csdn.net/liqingtx/article/details/60330555 个人笔记Redis是一种基于C语言开发的NoSql缓存工具，主要应用于非关系型大数据的存储查询 优势 Redis能读的速度是110000次/s,写的速度是81000次/s 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的，多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性 escape&gt; Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情（比如交集，并集，差集）。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问 基于Windows安装详细的教程在参考链接中已经给出中已经给出，下面看看我的安装步骤Redis最关键的是服务端和数据库类似，是Redis的核心所在；Redis客户端提供了Redis数据的可视化工具，并提供了一些简单的功能。我们先安装客户端。。。 一般windows应用程序，双击一直点下一步就好了，这样我们就装好客户端了；接下来是服务端 我们下载服务端程序,解压文件，双击点开文件夹 双击点开文件夹 然后我们运行run.bat，或者以运行cmd进入当前目录，执行redis-server.exe redis.conf 可以发现Redis服务端已经安装成功，端口号为6479 现在我们打开Redis客户端管理工具，点击Add New Connection 可以发现客户端连接一个缓存服务器，需要配置Name（名称）,Host（IP）,Port(端口号)，Auth(理解为密码)。我们给这个缓存库起个名字叫做LocalRedis ；Host是你要连接的缓存服务器的地址；这里我们127.0.0.1； Port在安装的时候已经给出是6479；接下来是密码，我们打开服务器的redis.conf文件 找到如下代码，requirepass后面的就是密码了 1requirepass ztredis(*)134&amp;^%xswed 现在我们就可以登录客户端了 到这里，我们的安装步骤已经完成。 关于Redis一些理解 Redis默认是开启持久化的，可根据业务需要关闭，只当作缓存来用，具体在redis.conf配置 redis.conf文件为Redis服务的配置文件，在这里可配置一些参数，比如持久化，空闲超时时限，Redis缓存库数（默认是15），缓存时间等等 Redis可以根据服务器硬件资源分配给缓存相应的内存资源，具体在redis.conf配置 Redis持久化很重要 下一篇博客会给出具体的Redis+.net的Demo代码","tags":[{"name":"缓存","slug":"缓存","permalink":"https://github-lu.github.io/tags/缓存/"}]},{"title":"程序员的浪漫","date":"2018-04-01T10:43:06.000Z","path":"2018/04/01/程序员的浪漫/","text":"我们程序员在追求爱情方面也是非常浪漫的，利用HTML5知识自制的HTML5爱心表白动画，画面非常温馨甜蜜。 演示效果 演示地址： http://118.24.121.243/ 源码地址： https://github.com/zhangdianlei/HTML5-love-you-master","tags":[{"name":"浪漫","slug":"浪漫","permalink":"https://github-lu.github.io/tags/浪漫/"}]},{"title":"Hexo常用命令","date":"2018-03-30T08:39:34.000Z","path":"2018/03/30/Hexo常用命令/","text":"Hexo常用命令笔记生成1$ hexo g 启动服务预览1$ hexo server 部署1$ hexo d 清理1$ hexo clean","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github-lu.github.io/tags/Hexo/"}]},{"title":"Sql脚本","date":"2018-03-30T08:39:34.000Z","path":"2018/03/30/Sql脚本/","text":"Sql脚本笔记快速查看表结构假如有一天和别人对接功能，别人给你扔过来个数据库，里面有几张表。如果手动去点击查询的话效率会非常的慢。以下Sql代码执行查询后会将表的的字段说明，类型，IsNULL等信息清楚的展示出来。当然前提是表中有字段说明，没有的话就得慢慢摸索了。。。 Sql数据库查询表结构可以通过以下代码查询 12345678910111213141516171819202122232425262728293031323334353637383940414243$ --快速查看表结构（比较全面的）SELECT CASE WHEN col.colorder = 1 THEN obj.name ELSE '' END AS 表名, col.colorder AS 序号 , col.name AS 列名 , ISNULL(ep.[value], '') AS 列说明 , t.name AS 数据类型 , col.length AS 长度 , ISNULL(COLUMNPROPERTY(col.id, col.name, 'Scale'), 0) AS 小数位数 , CASE WHEN COLUMNPROPERTY(col.id, col.name, 'IsIdentity') = 1 THEN '√' ELSE '' END AS 标识 , CASE WHEN EXISTS ( SELECT 1 FROM dbo.sysindexes si INNER JOIN dbo.sysindexkeys sik ON si.id = sik.id AND si.indid = sik.indid INNER JOIN dbo.syscolumns sc ON sc.id = sik.id AND sc.colid = sik.colid INNER JOIN dbo.sysobjects so ON so.name = si.name AND so.xtype = 'PK' WHERE sc.id = col.id AND sc.colid = col.colid ) THEN '√' ELSE '' END AS 主键 , CASE WHEN col.isnullable = 1 THEN '√' ELSE '' END AS 允许空 , ISNULL(comm.text, '') AS 默认值FROM dbo.syscolumns col LEFT JOIN dbo.systypes t ON col.xtype = t.xusertype inner JOIN dbo.sysobjects obj ON col.id = obj.id AND obj.xtype = 'U' AND obj.status &gt;= 0 LEFT JOIN dbo.syscomments comm ON col.cdefault = comm.id LEFT JOIN sys.extended_properties ep ON col.id = ep.major_id AND col.colid = ep.minor_id AND ep.name = 'MS_Description' LEFT JOIN sys.extended_properties epTwo ON obj.id = epTwo.major_id AND epTwo.minor_id = 0 AND epTwo.name = 'MS_Description'WHERE obj.name = 'NcCorporation'--表名ORDER BY col.colorder ; Sql循环插入100万条数据我们经常会用代码处理一些大数据，Sql执行效率会显得异常重要。以下代码是循环插入100万条数据，可模拟业务数据进行Sql代码调优。 首先创建Student表 12345$ create table student(sno int ,sname VARCHAR(200)) 向数据库中插入100万条随机姓名 123456789101112131415161718$ DECLARE @LN VARCHAR(300),@MN VARCHAR(200),@FN VARCHAR(200)DECLARE @LN_N INT,@MN_N INT,@FN_N INTSET @LN='李王张刘陈杨黄赵周吴徐孙朱马胡郭林何高梁郑罗宋谢唐韩曹许邓萧冯曾程蔡彭潘袁于董余苏叶吕魏蒋田杜丁沈姜范江傅钟卢汪戴崔任陆廖姚方金邱夏谭韦贾邹石熊孟秦阎薛侯雷白龙段郝孔邵史毛常万顾赖武康贺严尹钱施牛洪龚'SET @MN='德绍宗邦裕傅家積善昌世贻维孝友继绪定呈祥大正启仕执必定仲元魁家生先泽远永盛在人为任伐风树秀文光谨潭棰'SET @FN='丽云峰磊亮宏红洪量良梁良粮靓七旗奇琪谋牟弭米密祢磊类蕾肋庆情清青兴幸星刑'SET @LN_N=LEN(@LN)SET @MN_N=LEN(@MN)SET @FN_N=LEN(@FN)DECLARE @TMP VARCHAR(1000),@I INTSET @I=100WHILE @I&lt;1000000BEGIN SET @TMP=CAST(SUBSTRING(@LN,CAST(RAND()*@LN_N AS INT),1) AS VARCHAR) SET @TMP=@TMP+CAST(SUBSTRING(@MN,CAST(RAND()*@MN_N AS INT),1) AS VARCHAR) SET @TMP=@TMP+CAST(SUBSTRING(@FN,CAST(RAND()*@FN_N AS INT),1) AS VARCHAR) INSERT INTO student(sno,sname)VALUES('2005'+@I,@TMP) SET @I=@I+1end","tags":[{"name":"sql","slug":"sql","permalink":"https://github-lu.github.io/tags/sql/"},{"name":"数据库","slug":"数据库","permalink":"https://github-lu.github.io/tags/数据库/"}]},{"title":"异步多线程","date":"2017-10-04T03:20:11.000Z","path":"2017/10/04/异步多线程/","text":"今天做的笔记是异步多线程 详细内容参考：https://kb.cnblogs.com/page/116095/ 个人笔记 当需要执行I/O操作时，使用异步操作比使用线程+同步I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。 而线程的适用范围则是那种需要长时间CPU运算的场合，例如耗时较长的图形处理和算法执行。但是往往由于使用线程编程的简单和符合习惯，所以很多朋友往往会使用线程来执行耗时较长的I/O操作。这样在只有少数几个并发操作的时候还无伤大雅，如果需要处理大量的并发操作时就不合适了 多线程和异步操作的异同多线程和异步操作两者都可以达到避免调用线程阻塞的目的，从而提高软件的可响应性。甚至有些时候我们就认为多线程和异步操作是等同的概念。但是，多线程和异步操作还是有一些区别的。而这些区别造成了使用多线程和异步操作的时机的区别。 异步操作的本质（重点）所有的程序最终都会由计算机硬件来执行，所以为了更好的理解异步操作的本质，我们有必要了解一下它的硬件基础。 熟悉电脑硬件的朋友肯定对DMA这个词不陌生，硬盘、光驱的技术规格中都有明确DMA的模式指标，其实网卡、声卡、显卡也是有DMA功能的。DMA就是直接内存访问的意思，也就是说，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。只要CPU在发起数据传输时发送一个指令，硬件就开始自己和内存交换数据，在传输完成之后硬件会触发一个中断来通知操作完成。这些无须消耗CPU时间的I/O操作正是异步操作的硬件基础。所以即使在DOS这样的单进程（而且无线程概念）系统中也同样可以发起异步的DMA操作。 线程的本质（重点）线程不是一个计算机硬件的功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。 抽象示例在游戏中有个人物A，现在有任务物品B和任务物品C，分别完成任务B和C，现在问怎么完成两个两个任务？ 平民模式：A跑到B任务地点完成任务B，再跑到C任务地点完成任务C 异步模式（开挂模式）：A不用跑路了，站在完成任务B和任务C 多线程模式（开挂模式）：A采用影分身之术分为两个人，人别区完成任务B和任务C 基于C#语言Async和Await代码实现异步示例12345678910111213141516171819202122232425262728293031323334353637383940414243/// &lt;summary&gt;/// 主方法/// &lt;/summary&gt;public async void TaskTest()&#123; Stopwatch sw = new Stopwatch(); sw.Start(); var result = await Sum2Async(); Console.WriteLine($&quot;当前返回结果：&#123;result&#125;&quot;); sw.Stop(); TimeSpan ts2 = sw.Elapsed; Console.WriteLine($&quot;Stopwatch总共花费：&#123;ts2.TotalMilliseconds&#125;ms.&quot;);&#125;/// &lt;summary&gt;/// 获取count1/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;int&gt; Count1Async()&#123; await Task.Delay(3000); return 1;&#125;/// &lt;summary&gt;/// 获取count2/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;int&gt; Count2Async()&#123; await Task.Delay(3000); return 2;&#125;/// &lt;summary&gt;/// 返回count1+count2/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;int&gt; Sum2Async()&#123; var task1 = Count1Async(); var task2 = Count2Async(); await Task.Delay(3000); return await task1 + await task2;&#125; 执行结果 12当前返回结果：3Stopwatch总共花费：3052.0493ms. 异步方法总结： 方法签名包括async修饰符，有个修饰符的就能知道这是个异步方法 异步方法的命名，按照惯例，以“Async”后缀结尾，规范。。。 返回类型只能是这三种：Task,Task或void，规定。。。 方法通常至少包括一个await表达式，await标记了一个点，这个点就是直到异步操作完成后异步方法才继续执行。同时，方法是延迟的，控制返回到方法的调用者。（核心） 多线程代码示例12345678910111213141516/// &lt;summary&gt;/// 安装服务/// &lt;/summary&gt;/// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;private void BtnInstall_Click(object sender, EventArgs e)&#123; new Thread(new ThreadStart(new Action(() =&gt; &#123; if (!CheckServerState().IsExite) &#123; this.InstallService(serviceFilePath); &#125; MessageBox.Show(&quot;服务已安装&quot;); &#125;))).Start();&#125; 一个进程可以创建一个或多个线程以执行与该进程关联的部分程序代码。在C#中，线程是使用Thread类处理的，该类在System.Threading命名空间中。使用Thread类创建线程时，只需要提供线程入口，线程入口告诉程序让这个线程做什么。通过实例化一个Thread类的对象就可以创建一个线程。创建新的Thread对象时，将创建新的托管线程。Thread类接收一个ThreadStart委托或ParameterizedThreadStart委托的构造函数，该委托包装了调用Start方法时由新线程调用的方法 。 多线程方法笔记 线程也是程序，所以线程需要占用内存，线程越多，占用内存也越多。 多线程需要协调和管理，所以需要占用CPU时间以便跟踪线程。 线程之间对共享资源的访问会相互影响，必须解决争用共享资源的问题。 线程太多会导致控制太复杂，最终可能造成很多程序缺陷。","tags":[{"name":".net","slug":"net","permalink":"https://github-lu.github.io/tags/net/"}]},{"title":"堆&栈&堆栈&队列","date":"2017-08-04T03:20:11.000Z","path":"2017/08/04/堆-栈-堆栈-队列/","text":"今天做的笔记是基本数据结构知识 个人笔记 大学里面那本严蔚敏的数据结构不厚，内容丰富，但是复杂问题的讲解方面篇幅这样就少了，比较难理解，c也不是很擅长，但是基本的思路还是有的。 简单的链表，数组，堆栈，队列，图，几个排序算法。 技术与通俗知乎上看到一个人对数据结构的看法，我觉的说的很好，在这里引用一下 如果说 Java 是自动档轿车，C 就是手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A 开到 B，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。如果你对这两件事都不感兴趣也就罢了，数据结构懂得用就好。但若你此生在编程领域还有点更高的追求，数据结构是绕不开的课题。 Java 替你做了太多事情，那么多动不动还支持范型的容器类，加上垃圾收集，会让你觉得编程很容易。但你有没有想过，那些容器类是怎么来的，以及它存在的意义是什么？最粗浅的，比如 ArrayList 这个类，你想过它的存在是多么大的福利吗——一个可以随机访问、自动增加容量的数组，这种东西 C 是没有的，要自己实现。但是，具体怎么实现呢？如果你对这种问题感兴趣，那数据结构是一定要看的。甚至，面向对象编程范式本身，就是个数据结构问题：怎么才能把数据和操作数据的方法封装到一起，来造出 class / prototype 这种东西？ 此外，很重要的一点是，数据结构也是通向各种实用算法的基石，所以学习数据结构都是提升内力的事情。 开始堆：什么是堆？又该怎么理解呢？堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵完全二叉树。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契 堆等。 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。 堆是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程。 堆是指程序运行时申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。 栈：什么是栈？又该怎么理解呢？ 栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。 栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来（先进后出） 栈(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。 堆栈：什么是堆栈？又该怎么理解呢？注意：其实堆栈本身就是栈，只是换了个抽象的名字。 堆栈的特性： 最后一个放入堆栈中的物体总是被最先拿出来， 这个特性通常称为后进先出(LIFO)队列。 堆栈中定义了一些操作。 两个最重要的是PUSH和POP。 PUSH操作在堆栈的顶部加入一 个元素。POP操作相反， 在堆栈顶部移去一个元素， 并将堆栈的大小减一。 堆、栈区别总结 ： 1.堆栈空间分配 ①栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 ②堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 2.堆栈缓存方式 ①栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。 ②堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 3.堆栈数据结构区别 ①堆（数据结构）：堆可以被看成是一棵树，如：堆排序。 ②栈（数据结构）：一种先进后出的数据结构。 队列：什么是队列？又该怎么理解呢？① 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 ②队列中没有元素时，称为空队列。 ③建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置。 ④队列采用的FIFO(first in first out)，新元素（等待进入队列的元素）总是被插入到链表的尾部，而读取的时候总是从链表的头部开始读取。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便。（先进先出） 堆、栈、队列之间的区别是？①堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。 ②栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来。（后进先出） ③队列只能在队头做删除操作,在队尾做插入操作.而栈只能在栈顶做插入和删除操作。（先进先出）","tags":[{"name":".net","slug":"net","permalink":"https://github-lu.github.io/tags/net/"}]}]